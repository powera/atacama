<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🇱🇹 Lithuanian Vocabulary Flash Cards</title>
    
    <!-- React CDN -->
    <script crossorigin src="/js/third_party/react.production.min.js"></script>
    <script crossorigin src="/js/third_party/react-dom.production.min.js"></script>
    <script crossorigin src="/js/third_party/prop-types.min.js"></script>
    
    <!-- CSS Files -->
    <link rel="stylesheet" href="/css/widget_settings.css">
    <link rel="stylesheet" href="/css/common.css">
    <link rel="stylesheet" href="/css/trakaido.css">

    
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background-color: #f5f5f5;
        }
        #react-root {
            min-height: 100vh;
        }
    </style>
</head>
<body>
    <div id="react-root"></div>
    
    <!-- Lithuanian API -->
    <script src="/js/lithuanianApi.js"></script>
    
    <!-- Compiled React Components -->
    <script>
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _excluded = ["children"];
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function _objectWithoutProperties(e, t) { if (null == e) return {}; var o, r, i = _objectWithoutPropertiesLoose(e, t); if (Object.getOwnPropertySymbols) { var n = Object.getOwnPropertySymbols(e); for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]); } return i; }
function _objectWithoutPropertiesLoose(r, e) { if (null == r) return {}; var t = {}; for (var n in r) if ({}.hasOwnProperty.call(r, n)) { if (-1 !== e.indexOf(n)) continue; t[n] = r[n]; } return t; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// Access React hooks from the global React object
var _React = React,
  useState = _React.useState,
  useEffect = _React.useEffect,
  useRef = _React.useRef,
  useCallback = _React.useCallback;

/**
 * Default settings configuration
 */
var DEFAULT_SETTINGS = {
  // Audio & Feedback
  audioEnabled: true,
  soundVolume: 0.7,
  // 0-1 range
  hapticFeedback: true,
  // For mobile devices

  // Difficulty & Learning
  difficulty: 'medium',
  // 'easy', 'medium', 'hard'
  adaptiveDifficulty: true,
  // Auto-adjust based on performance
  hintsEnabled: true,
  // Personalization
  userName: '',
  preferredLanguage: 'en',
  // For multi-language widgets

  // Visual & Animations
  animations: true,
  reducedMotion: false,
  // Accessibility: honor prefers-reduced-motion
  theme: 'auto',
  // 'auto', 'light', 'dark', 'high-contrast'
  fontSize: 'medium',
  // 'small', 'medium', 'large'

  // Timing & Flow
  autoAdvance: false,
  defaultDelay: 2.5,
  // seconds, range 1.0 to 7.5

  // Privacy & Data
  anonymousMode: false,
  // Don't track any progress/stats
  shareProgress: true,
  // Allow sharing achievements

  // Accessibility
  keyboardShortcuts: true,
  screenReaderMode: false,
  highContrastMode: false
};

/**
 * Settings storage key for localStorage
 */
var SETTINGS_STORAGE_KEY = 'atacama_global_settings';

/**
 * Load settings from localStorage with fallback to defaults
 */
var loadSettings = function loadSettings() {
  try {
    var stored = localStorage.getItem(SETTINGS_STORAGE_KEY);
    if (stored) {
      var parsed = JSON.parse(stored);
      // Merge with defaults to handle new settings
      return _objectSpread(_objectSpread({}, DEFAULT_SETTINGS), parsed);
    }
  } catch (error) {
    console.warn('Failed to load settings from localStorage:', error);
  }
  return _objectSpread({}, DEFAULT_SETTINGS);
};

/**
 * Save settings to localStorage
 */
var saveSettings = function saveSettings(settings) {
  try {
    localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
  } catch (error) {
    console.warn('Failed to save settings to localStorage:', error);
  }
};

/**
 * Custom hook for global settings management
 * 
 * @param {Object} options - Configuration options
 * @param {Array<string>} options.usedSettings - Array of setting keys that should be shown on the first page
 * 
 * @returns {Object} Object containing:
 *   - settings: current settings object
 *   - updateSetting: function to update a single setting
 *   - updateSettings: function to update multiple settings at once
 *   - resetSettings: function to reset all settings to defaults
 *   - showGlobalSettings: boolean indicating if settings modal is open
 *   - toggleGlobalSettings: function to toggle settings modal
 *   - readGlobalSettings: function to get current settings (for compatibility)
 *   - SettingsModal: React component for the settings modal
 *   - SettingsToggle: React component for the settings toggle button
 * 
 * @example
 * const MyWidget = () => {
 *   const { 
 *     settings, 
 *     updateSetting, 
 *     SettingsModal,
 *     SettingsToggle
 *   } = useGlobalSettings({
 *     usedSettings: ['audioEnabled', 'difficulty', 'autoAdvance']
 *   });
 *   
 *   return (
 *     <div>
 *       <SettingsToggle />
 *       {settings.audioEnabled && <audio autoPlay />}
 *       <div className={`difficulty-${settings.difficulty}`}>
 *         Game content here...
 *       </div>
 *       <SettingsModal />
 *     </div>
 *   );
 * };
 */
var useGlobalSettings = function useGlobalSettings() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var _options$usedSettings = options.usedSettings,
    usedSettings = _options$usedSettings === void 0 ? [] : _options$usedSettings;
  var _useState = useState(loadSettings),
    _useState2 = _slicedToArray(_useState, 2),
    settings = _useState2[0],
    setSettings = _useState2[1];
  var _useState3 = useState(false),
    _useState4 = _slicedToArray(_useState3, 2),
    showGlobalSettings = _useState4[0],
    setShowGlobalSettings = _useState4[1];
  var _useState5 = useState(usedSettings.length > 0 ? 'used' : 'general'),
    _useState6 = _slicedToArray(_useState5, 2),
    activeTab = _useState6[0],
    setActiveTab = _useState6[1];
  var modalRef = useRef(null);
  var scrollPositionRef = useRef(0);

  // Save settings whenever they change, but debounce to avoid excessive saves
  var debouncedSaveSettings = useCallback(function () {
    var timeoutId = null;
    return function (newSettings) {
      if (timeoutId) clearTimeout(timeoutId);
      timeoutId = setTimeout(function () {
        saveSettings(newSettings);
      }, 100);
    };
  }(), []);
  useEffect(function () {
    debouncedSaveSettings(settings);
  }, [settings, debouncedSaveSettings]);

  // Check for system preferences on mount
  useEffect(function () {
    if (window.matchMedia) {
      var prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      var prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      setSettings(function (prev) {
        return _objectSpread(_objectSpread({}, prev), {}, {
          reducedMotion: prev.reducedMotion || prefersReducedMotion,
          theme: prev.theme === 'auto' ? prefersDark ? 'dark' : 'light' : prev.theme
        });
      });
    }
  }, []);

  // Memoized update function to prevent unnecessary re-renders
  var updateSetting = useCallback(function (key, value) {
    // Store current scroll position of the modal if it exists
    if (modalRef.current) {
      scrollPositionRef.current = modalRef.current.scrollTop;
    }
    setSettings(function (prev) {
      return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, key, value));
    });
  }, []);

  // Update multiple settings at once
  var updateSettings = useCallback(function (updates) {
    if (modalRef.current) {
      scrollPositionRef.current = modalRef.current.scrollTop;
    }
    setSettings(function (prev) {
      return _objectSpread(_objectSpread({}, prev), updates);
    });
  }, []);

  // Restore scroll position after settings update
  useEffect(function () {
    if (scrollPositionRef.current > 0 && modalRef.current) {
      // Use requestAnimationFrame to ensure DOM has updated
      requestAnimationFrame(function () {
        modalRef.current.scrollTop = scrollPositionRef.current;
      });
    }
  }, [settings]);
  var resetSettings = useCallback(function () {
    // Store current scroll position of the modal if it exists
    if (modalRef.current) {
      scrollPositionRef.current = modalRef.current.scrollTop;
    }
    setSettings(_objectSpread({}, DEFAULT_SETTINGS));
  }, []);
  var toggleGlobalSettings = useCallback(function () {
    setShowGlobalSettings(function (prev) {
      // Reset scroll position reference when opening or closing
      scrollPositionRef.current = 0;
      return !prev;
    });
  }, []);
  var readGlobalSettings = useCallback(function () {
    return _objectSpread({}, settings);
  }, [settings]);

  // Handle escape key and outside clicks
  useEffect(function () {
    var handleKeyDown = function handleKeyDown(event) {
      if (event.key === 'Escape' && showGlobalSettings) {
        setShowGlobalSettings(false);
      }
    };
    var handleClickOutside = function handleClickOutside(event) {
      // Check if modalRef and modalRef.current exist before calling contains
      if (modalRef.current && event.target && !modalRef.current.contains(event.target)) {
        setShowGlobalSettings(false);
      }
    };
    if (showGlobalSettings) {
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('mousedown', handleClickOutside);
    }
    return function () {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [showGlobalSettings]);

  /**
   * Settings Toggle Button Component
   */
  var SettingsToggle = useCallback(function (_ref) {
    var children = _ref.children,
      props = _objectWithoutProperties(_ref, _excluded);
    return /*#__PURE__*/React.createElement("button", _extends({
      onClick: toggleGlobalSettings,
      className: "w-settings-toggle",
      "aria-label": "Open global settings"
    }, props), /*#__PURE__*/React.createElement("span", {
      className: "w-settings-icon"
    }, "\u2699\uFE0F"), children || 'Settings');
  }, [toggleGlobalSettings]);

  /**
   * Helper function to render individual setting components
   */
  var renderSetting = function renderSetting(settingKey) {
    switch (settingKey) {
      case 'userName':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-label"
        }, "Your Name"), /*#__PURE__*/React.createElement("input", {
          type: "text",
          value: settings.userName,
          onChange: function onChange(e) {
            return updateSetting('userName', e.target.value);
          },
          placeholder: "Enter your name (optional)",
          className: "w-setting-input"
        }), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Personalize your experience with widgets"));
      case 'difficulty':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-label"
        }, "Default Difficulty"), /*#__PURE__*/React.createElement("select", {
          value: settings.difficulty,
          onChange: function onChange(e) {
            return updateSetting('difficulty', e.target.value);
          },
          className: "w-setting-select"
        }, /*#__PURE__*/React.createElement("option", {
          value: "easy"
        }, "Easy"), /*#__PURE__*/React.createElement("option", {
          value: "medium"
        }, "Medium"), /*#__PURE__*/React.createElement("option", {
          value: "hard"
        }, "Hard")), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Default difficulty for learning widgets"));
      case 'adaptiveDifficulty':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-checkbox"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          checked: settings.adaptiveDifficulty,
          onChange: function onChange(e) {
            return updateSetting('adaptiveDifficulty', e.target.checked);
          }
        }), "Adaptive Difficulty"), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Automatically adjust difficulty based on your performance"));
      case 'hintsEnabled':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-checkbox"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          checked: settings.hintsEnabled,
          onChange: function onChange(e) {
            return updateSetting('hintsEnabled', e.target.checked);
          }
        }), "Enable Hints"), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Show helpful hints when available"));
      case 'preferredLanguage':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-label"
        }, "Preferred Language"), /*#__PURE__*/React.createElement("select", {
          value: settings.preferredLanguage,
          onChange: function onChange(e) {
            return updateSetting('preferredLanguage', e.target.value);
          },
          className: "w-setting-select"
        }, /*#__PURE__*/React.createElement("option", {
          value: "en"
        }, "English"), /*#__PURE__*/React.createElement("option", {
          value: "es"
        }, "Espa\xF1ol"), /*#__PURE__*/React.createElement("option", {
          value: "fr"
        }, "Fran\xE7ais"), /*#__PURE__*/React.createElement("option", {
          value: "de"
        }, "Deutsch"), /*#__PURE__*/React.createElement("option", {
          value: "zh"
        }, "\u4E2D\u6587"), /*#__PURE__*/React.createElement("option", {
          value: "ja"
        }, "\u65E5\u672C\u8A9E")), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Language for multi-language widgets"));
      case 'audioEnabled':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-checkbox"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          checked: settings.audioEnabled,
          onChange: function onChange(e) {
            return updateSetting('audioEnabled', e.target.checked);
          }
        }), "Enable Audio"), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Play sounds and audio feedback in widgets"));
      case 'soundVolume':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-label"
        }, "Sound Volume"), /*#__PURE__*/React.createElement("div", {
          className: "w-range-input-wrapper",
          style: {
            '--range-progress': "".concat(settings.soundVolume * 100, "%")
          }
        }, /*#__PURE__*/React.createElement("input", {
          type: "range",
          min: "0",
          max: "1",
          step: "0.1",
          value: settings.soundVolume,
          onInput: function onInput(e) {
            var newValue = parseFloat(e.target.value);
            // Update visual feedback immediately without triggering re-render
            e.target.parentNode.style.setProperty('--range-progress', "".concat(newValue * 100, "%"));
            // Update the displayed value
            var valueDisplay = e.target.parentNode.parentNode.querySelector('.w-range-value-current');
            if (valueDisplay) {
              valueDisplay.textContent = "".concat(Math.round(newValue * 100), "%");
            }
          },
          onChange: function onChange(e) {
            var newValue = parseFloat(e.target.value);
            updateSetting('soundVolume', newValue);
          },
          className: "w-setting-input",
          disabled: !settings.audioEnabled
        })), /*#__PURE__*/React.createElement("div", {
          className: "w-range-value-display"
        }, /*#__PURE__*/React.createElement("span", {
          className: "w-range-value-min"
        }, "\uD83D\uDD07"), /*#__PURE__*/React.createElement("span", {
          className: "w-range-value-current"
        }, Math.round(settings.soundVolume * 100), "%"), /*#__PURE__*/React.createElement("span", {
          className: "w-range-value-max"
        }, "\uD83D\uDD0A")));
      case 'hapticFeedback':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-checkbox"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          checked: settings.hapticFeedback,
          onChange: function onChange(e) {
            return updateSetting('hapticFeedback', e.target.checked);
          }
        }), "Haptic Feedback"), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Vibration feedback on mobile devices"));
      case 'defaultDelay':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-label"
        }, "Default Timing"), /*#__PURE__*/React.createElement("div", {
          className: "w-range-input-wrapper",
          style: {
            '--range-progress': "".concat((settings.defaultDelay - 1.0) / (7.5 - 1.0) * 100, "%")
          }
        }, /*#__PURE__*/React.createElement("input", {
          type: "range",
          min: "1.0",
          max: "7.5",
          step: "0.25",
          value: settings.defaultDelay,
          onInput: function onInput(e) {
            var newValue = parseFloat(e.target.value);
            // Update visual feedback immediately without triggering re-render
            e.target.parentNode.style.setProperty('--range-progress', "".concat((newValue - 1.0) / (7.5 - 1.0) * 100, "%"));
            // Update the displayed value
            var valueDisplay = e.target.parentNode.parentNode.querySelector('.w-range-value-current');
            if (valueDisplay) {
              valueDisplay.textContent = "".concat(newValue, "s");
            }
          },
          onChange: function onChange(e) {
            var newValue = parseFloat(e.target.value);
            updateSetting('defaultDelay', newValue);
          },
          className: "w-setting-input"
        })), /*#__PURE__*/React.createElement("div", {
          className: "w-range-value-display"
        }, /*#__PURE__*/React.createElement("span", {
          className: "w-range-value-min"
        }, "1.0s"), /*#__PURE__*/React.createElement("span", {
          className: "w-range-value-current"
        }, settings.defaultDelay, "s"), /*#__PURE__*/React.createElement("span", {
          className: "w-range-value-max"
        }, "7.5s")), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Default timing for transitions and auto-advance delays"));
      case 'autoAdvance':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-checkbox"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          checked: settings.autoAdvance,
          onChange: function onChange(e) {
            return updateSetting('autoAdvance', e.target.checked);
          }
        }), "Auto-Advance"), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Automatically advance to next question after correct answers"));
      case 'theme':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-label"
        }, "Theme"), /*#__PURE__*/React.createElement("select", {
          value: settings.theme,
          onChange: function onChange(e) {
            return updateSetting('theme', e.target.value);
          },
          className: "w-setting-select"
        }, /*#__PURE__*/React.createElement("option", {
          value: "auto"
        }, "Auto (System)"), /*#__PURE__*/React.createElement("option", {
          value: "light"
        }, "Light"), /*#__PURE__*/React.createElement("option", {
          value: "dark"
        }, "Dark"), /*#__PURE__*/React.createElement("option", {
          value: "high-contrast"
        }, "High Contrast")), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Choose your preferred color theme"));
      case 'fontSize':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-label"
        }, "Font Size"), /*#__PURE__*/React.createElement("select", {
          value: settings.fontSize,
          onChange: function onChange(e) {
            return updateSetting('fontSize', e.target.value);
          },
          className: "w-setting-select"
        }, /*#__PURE__*/React.createElement("option", {
          value: "small"
        }, "Small"), /*#__PURE__*/React.createElement("option", {
          value: "medium"
        }, "Medium"), /*#__PURE__*/React.createElement("option", {
          value: "large"
        }, "Large")), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Adjust text size for better readability"));
      case 'animations':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-checkbox"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          checked: settings.animations,
          onChange: function onChange(e) {
            return updateSetting('animations', e.target.checked);
          }
        }), "Enable Animations"), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Show smooth transitions and animations"));
      case 'reducedMotion':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-checkbox"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          checked: settings.reducedMotion,
          onChange: function onChange(e) {
            return updateSetting('reducedMotion', e.target.checked);
          }
        }), "Reduce Motion"), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Minimize animations for motion sensitivity"));
      case 'screenReaderMode':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-checkbox"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          checked: settings.screenReaderMode,
          onChange: function onChange(e) {
            return updateSetting('screenReaderMode', e.target.checked);
          }
        }), "Screen Reader Mode"), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Optimize for screen reader compatibility"));
      case 'highContrastMode':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-checkbox"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          checked: settings.highContrastMode,
          onChange: function onChange(e) {
            return updateSetting('highContrastMode', e.target.checked);
          }
        }), "High Contrast Mode"), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Increase visual contrast for better visibility"));
      case 'keyboardShortcuts':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-checkbox"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          checked: settings.keyboardShortcuts,
          onChange: function onChange(e) {
            return updateSetting('keyboardShortcuts', e.target.checked);
          }
        }), "Enable Keyboard Shortcuts"), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Use keyboard shortcuts for navigation"));
      case 'anonymousMode':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-checkbox"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          checked: settings.anonymousMode,
          onChange: function onChange(e) {
            return updateSetting('anonymousMode', e.target.checked);
          }
        }), "Anonymous Mode"), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Don't track progress or statistics"));
      case 'shareProgress':
        return /*#__PURE__*/React.createElement("div", {
          key: settingKey,
          className: "w-setting-group"
        }, /*#__PURE__*/React.createElement("label", {
          className: "w-setting-checkbox"
        }, /*#__PURE__*/React.createElement("input", {
          type: "checkbox",
          checked: settings.shareProgress,
          onChange: function onChange(e) {
            return updateSetting('shareProgress', e.target.checked);
          },
          disabled: settings.anonymousMode
        }), "Allow Progress Sharing"), /*#__PURE__*/React.createElement("p", {
          className: "w-setting-description"
        }, "Share achievements and progress with others"));
      default:
        return null;
    }
  };

  /**
   * Settings Modal Component
   */
  var SettingsModal = function SettingsModal() {
    if (!showGlobalSettings) return null;

    // Create tabs array, adding "Used Settings" tab if usedSettings is provided
    var tabs = [];
    if (usedSettings.length > 0) {
      tabs.push({
        id: 'used',
        label: 'Used Settings',
        icon: '⭐'
      });
    }
    tabs.push({
      id: 'general',
      label: 'General',
      icon: '⚙️'
    }, {
      id: 'audio',
      label: 'Audio & Feedback',
      icon: '🔊'
    }, {
      id: 'visual',
      label: 'Visual',
      icon: '🎨'
    }, {
      id: 'accessibility',
      label: 'Accessibility',
      icon: '♿'
    }, {
      id: 'privacy',
      label: 'Privacy',
      icon: '🔒'
    });
    return /*#__PURE__*/React.createElement("div", {
      className: "w-settings-overlay"
    }, /*#__PURE__*/React.createElement("div", {
      ref: modalRef,
      className: "w-settings-modal"
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-settings-header"
    }, /*#__PURE__*/React.createElement("h2", {
      className: "w-settings-title"
    }, "Global Settings"), /*#__PURE__*/React.createElement("button", {
      onClick: toggleGlobalSettings,
      className: "w-settings-close",
      "aria-label": "Close settings"
    }, "\xD7")), /*#__PURE__*/React.createElement("div", {
      className: "w-settings-tabs"
    }, tabs.map(function (tab) {
      return /*#__PURE__*/React.createElement("button", {
        key: tab.id,
        onClick: function onClick() {
          return setActiveTab(tab.id);
        },
        className: "w-settings-tab ".concat(activeTab === tab.id ? 'active' : '')
      }, /*#__PURE__*/React.createElement("span", {
        className: "w-settings-tab-icon"
      }, tab.icon), /*#__PURE__*/React.createElement("span", {
        className: "w-settings-tab-label"
      }, tab.label));
    })), /*#__PURE__*/React.createElement("div", {
      className: "w-settings-form"
    }, activeTab === 'used' && /*#__PURE__*/React.createElement(React.Fragment, null, usedSettings.length > 0 ? usedSettings.map(function (settingKey) {
      return renderSetting(settingKey);
    }) : /*#__PURE__*/React.createElement("div", {
      className: "w-setting-group"
    }, /*#__PURE__*/React.createElement("p", {
      className: "w-setting-description"
    }, "No specific settings have been configured for this widget."))), activeTab === 'general' && /*#__PURE__*/React.createElement(React.Fragment, null, renderSetting('userName'), renderSetting('difficulty'), renderSetting('adaptiveDifficulty'), renderSetting('hintsEnabled'), renderSetting('preferredLanguage')), activeTab === 'audio' && /*#__PURE__*/React.createElement(React.Fragment, null, renderSetting('audioEnabled'), renderSetting('soundVolume'), renderSetting('hapticFeedback'), renderSetting('defaultDelay'), renderSetting('autoAdvance')), activeTab === 'visual' && /*#__PURE__*/React.createElement(React.Fragment, null, renderSetting('theme'), renderSetting('fontSize'), renderSetting('animations'), renderSetting('reducedMotion')), activeTab === 'accessibility' && /*#__PURE__*/React.createElement(React.Fragment, null, renderSetting('screenReaderMode'), renderSetting('highContrastMode'), renderSetting('keyboardShortcuts')), activeTab === 'privacy' && /*#__PURE__*/React.createElement(React.Fragment, null, renderSetting('anonymousMode'), renderSetting('shareProgress'))), /*#__PURE__*/React.createElement("div", {
      className: "w-settings-actions"
    }, /*#__PURE__*/React.createElement("button", {
      onClick: resetSettings,
      className: "w-settings-button w-settings-button-secondary"
    }, "Reset to Defaults"), /*#__PURE__*/React.createElement("button", {
      onClick: toggleGlobalSettings,
      className: "w-settings-button w-settings-button-primary"
    }, "Done"))));
  };
  return {
    settings: settings,
    updateSetting: updateSetting,
    updateSettings: updateSettings,
    resetSettings: resetSettings,
    showGlobalSettings: showGlobalSettings,
    toggleGlobalSettings: toggleGlobalSettings,
    readGlobalSettings: readGlobalSettings,
    SettingsModal: SettingsModal,
    SettingsToggle: SettingsToggle
  };
};
window.useGlobalSettings = useGlobalSettings;
;
window.useGlobalSettings = useGlobalSettings;



"use strict";

function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
// import { useState, useEffect, useRef, useCallback } from 'react';

/**
 * Custom hook for fullscreen functionality
 * 
 * @returns {Object} Object containing:
 *   - isFullscreen: boolean indicating if currently in fullscreen
 *   - toggleFullscreen: function to toggle fullscreen mode
 *   - containerRef: ref to attach to the element that should go fullscreen
 * 
 * @example
 * const MyWidget = () => {
 *   const { isFullscreen, toggleFullscreen, containerRef } = useFullscreen();
 *   
 *   return (
 *     <div ref={containerRef} className={isFullscreen ? 'w-fullscreen' : 'w-container'}>
 *       <button onClick={toggleFullscreen}>
 *         {isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen'}
 *       </button>
 *     </div>
 *   );
 * };
 */
var useFullscreen = function useFullscreen() {
  var _useState = useState(false),
    _useState2 = _slicedToArray(_useState, 2),
    isFullscreen = _useState2[0],
    setIsFullscreen = _useState2[1];
  var containerRef = useRef(null);
  var toggleFullscreen = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
      var element, _t;
      return _regenerator().w(function (_context) {
        while (1) switch (_context.n) {
          case 0:
            _context.p = 0;
            if (document.fullscreenElement) {
              _context.n = 8;
              break;
            }
            // Enter fullscreen mode
            element = containerRef.current || document.documentElement;
            if (!element.requestFullscreen) {
              _context.n = 2;
              break;
            }
            _context.n = 1;
            return element.requestFullscreen();
          case 1:
            _context.n = 7;
            break;
          case 2:
            if (!element.mozRequestFullScreen) {
              _context.n = 4;
              break;
            }
            _context.n = 3;
            return element.mozRequestFullScreen();
          case 3:
            _context.n = 7;
            break;
          case 4:
            if (!element.webkitRequestFullscreen) {
              _context.n = 6;
              break;
            }
            _context.n = 5;
            return element.webkitRequestFullscreen();
          case 5:
            _context.n = 7;
            break;
          case 6:
            if (!element.msRequestFullscreen) {
              _context.n = 7;
              break;
            }
            _context.n = 7;
            return element.msRequestFullscreen();
          case 7:
            _context.n = 15;
            break;
          case 8:
            if (!document.exitFullscreen) {
              _context.n = 10;
              break;
            }
            _context.n = 9;
            return document.exitFullscreen();
          case 9:
            _context.n = 15;
            break;
          case 10:
            if (!document.mozCancelFullScreen) {
              _context.n = 12;
              break;
            }
            _context.n = 11;
            return document.mozCancelFullScreen();
          case 11:
            _context.n = 15;
            break;
          case 12:
            if (!document.webkitExitFullscreen) {
              _context.n = 14;
              break;
            }
            _context.n = 13;
            return document.webkitExitFullscreen();
          case 13:
            _context.n = 15;
            break;
          case 14:
            if (!document.msExitFullscreen) {
              _context.n = 15;
              break;
            }
            _context.n = 15;
            return document.msExitFullscreen();
          case 15:
            _context.n = 17;
            break;
          case 16:
            _context.p = 16;
            _t = _context.v;
            console.error('Fullscreen toggle failed:', _t);
          case 17:
            return _context.a(2);
        }
      }, _callee, null, [[0, 16]]);
    }));
    return function toggleFullscreen() {
      return _ref.apply(this, arguments);
    };
  }();

  // Listen for fullscreen changes
  useEffect(function () {
    var handleFullscreenChange = function handleFullscreenChange() {
      setIsFullscreen(!!document.fullscreenElement);
    };
    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('msfullscreenchange', handleFullscreenChange);
    return function () {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
      document.removeEventListener('mozfullscreenchange', handleFullscreenChange);
      document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
      document.removeEventListener('msfullscreenchange', handleFullscreenChange);
    };
  }, []);
  return {
    isFullscreen: isFullscreen,
    toggleFullscreen: toggleFullscreen,
    containerRef: containerRef
  };
};
window.useFullscreen = useFullscreen;
;
window.useFullscreen = useFullscreen;



"use strict";

/**
 * Utility for safely accessing localStorage with error handling
 * 
 * This wrapper provides methods to safely interact with localStorage,
 * handling potential errors that might occur (like in private browsing mode
 * or when storage quota is exceeded).
 */
var safeStorage = {
  /**
   * Safely retrieves an item from localStorage
   * @param {string} key - The key to retrieve
   * @param {*} defaultValue - Value to return if key doesn't exist or an error occurs
   * @returns {string|null} The stored value or defaultValue
   */
  getItem: function getItem(key) {
    var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    try {
      return localStorage.getItem(key) || defaultValue;
    } catch (error) {
      console.error("Error reading ".concat(key, " from localStorage:"), error);
      return defaultValue;
    }
  },
  /**
   * Safely stores an item in localStorage
   * @param {string} key - The key to store under
   * @param {string} value - The value to store
   */
  setItem: function setItem(key, value) {
    try {
      localStorage.setItem(key, value);
    } catch (error) {
      console.error("Error saving ".concat(key, " to localStorage:"), error);
    }
  },
  /**
   * Safely removes an item from localStorage
   * @param {string} key - The key to remove
   */
  removeItem: function removeItem(key) {
    try {
      localStorage.removeItem(key);
    } catch (error) {
      console.error("Error removing ".concat(key, " from localStorage:"), error);
    }
  }
};
window.safeStorage = safeStorage;
;



"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var WordListManager = /*#__PURE__*/function () {
  function WordListManager(safeStorage, settings) {
    _classCallCheck(this, WordListManager);
    this.safeStorage = safeStorage;
    this.settings = settings;
    this.allWords = [];
    this.currentCard = 0;
    this.showAnswer = false;
    this.selectedAnswer = null;
    this.typedAnswer = '';
    this.typingFeedback = '';
    this.multipleChoiceOptions = [];
    this.stats = {
      correct: 0,
      incorrect: 0,
      total: 0
    };
    this.autoAdvanceTimer = null;
    this.onStateChange = null; // Callback for state updates
  }
  return _createClass(WordListManager, [{
    key: "setStateChangeCallback",
    value: function setStateChangeCallback(callback) {
      this.onStateChange = callback;
    }
  }, {
    key: "notifyStateChange",
    value: function notifyStateChange() {
      if (this.onStateChange) {
        this.onStateChange({
          allWords: this.allWords,
          currentCard: this.currentCard,
          showAnswer: this.showAnswer,
          selectedAnswer: this.selectedAnswer,
          typedAnswer: this.typedAnswer,
          typingFeedback: this.typingFeedback,
          multipleChoiceOptions: this.multipleChoiceOptions,
          stats: this.stats,
          autoAdvanceTimer: this.autoAdvanceTimer
        });
      }
    }
  }, {
    key: "generateWordsList",
    value: function generateWordsList(selectedGroups, corporaData) {
      if (Object.keys(corporaData).length === 0) {
        this.allWords = [];
        this.currentCard = 0;
        this.showAnswer = false;
        this.selectedAnswer = null;
        this.notifyStateChange();
        return;
      }
      var words = [];
      Object.entries(selectedGroups).forEach(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          corpus = _ref2[0],
          groups = _ref2[1];
        if (corporaData[corpus] && groups.length > 0) {
          groups.forEach(function (group) {
            if (corporaData[corpus].groups[group]) {
              var _words;
              var groupWords = corporaData[corpus].groups[group].map(function (word) {
                return _objectSpread(_objectSpread({}, word), {}, {
                  corpus: corpus,
                  group: group
                });
              });
              (_words = words).push.apply(_words, _toConsumableArray(groupWords));
            }
          });
        }
      });

      // Always shuffle the cards
      words = words.sort(function () {
        return Math.random() - 0.5;
      });
      this.allWords = words;
      this.currentCard = 0;
      this.showAnswer = false;
      this.selectedAnswer = null;
      this.notifyStateChange();
    }
  }, {
    key: "generateMultipleChoiceOptions",
    value: function generateMultipleChoiceOptions(studyMode, quizMode) {
      var currentWord = this.allWords[this.currentCard];
      if (!currentWord) return;

      // For listening mode, determine correct answer based on listening mode type
      var correctAnswer;
      if (quizMode === 'listening') {
        // In listening mode: LT->LT shows Lithuanian options, LT->EN shows English options
        correctAnswer = studyMode === 'lithuanian-to-english' ? currentWord.english : currentWord.lithuanian;
      } else {
        // Regular multiple choice mode
        correctAnswer = studyMode === 'english-to-lithuanian' ? currentWord.lithuanian : currentWord.english;
      }

      // Determine number of options based on difficulty
      var numOptions = this.settings.difficulty === 'easy' ? 4 : this.settings.difficulty === 'medium' ? 6 : 8;
      var numWrongAnswers = numOptions - 1;

      // Determine which field to use for filtering and generating wrong answers
      var answerField;
      if (quizMode === 'listening') {
        answerField = studyMode === 'lithuanian-to-english' ? 'english' : 'lithuanian';
      } else {
        answerField = studyMode === 'english-to-lithuanian' ? 'lithuanian' : 'english';
      }
      var sameCorpusWords = this.allWords.filter(function (word) {
        return word.corpus === currentWord.corpus && word[answerField] !== correctAnswer;
      });
      var wrongAnswersSet = new Set();
      var wrongAnswers = [];

      // Gather wrong answers from same corpus - shuffle first to get random decoys
      var shuffledSameCorpusWords = _toConsumableArray(sameCorpusWords).sort(function () {
        return Math.random() - 0.5;
      });
      var _iterator = _createForOfIteratorHelper(shuffledSameCorpusWords),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var word = _step.value;
          var answer = word[answerField];
          if (answer !== correctAnswer && !wrongAnswersSet.has(answer)) {
            wrongAnswersSet.add(answer);
            wrongAnswers.push(answer);
            if (wrongAnswers.length >= numWrongAnswers) break;
          }
        }

        // Pad with any other words if needed
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (wrongAnswers.length < numWrongAnswers) {
        var fallbackWords = this.allWords.map(function (w) {
          return w[answerField];
        }).filter(function (ans) {
          return ans !== correctAnswer && !wrongAnswersSet.has(ans);
        }).sort(function () {
          return Math.random() - 0.5;
        }); // Shuffle fallback words too
        while (wrongAnswers.length < numWrongAnswers && fallbackWords.length > 0) {
          var randIdx = Math.floor(Math.random() * fallbackWords.length);
          var fallback = fallbackWords.splice(randIdx, 1)[0];
          wrongAnswers.push(fallback);
        }
      }
      var options = [correctAnswer].concat(wrongAnswers);

      // Sort alphabetically for medium and hard difficulty, otherwise shuffle
      if (this.settings.difficulty === 'medium' || this.settings.difficulty === 'hard') {
        options = options.sort();
        // Rearrange to fill columns first (left column, then right column)
        var rearranged = [];
        var half = Math.ceil(options.length / 2);
        for (var i = 0; i < half; i++) {
          rearranged.push(options[i]);
          if (i + half < options.length) {
            rearranged.push(options[i + half]);
          }
        }
        options = rearranged;
      } else {
        options = options.sort(function () {
          return Math.random() - 0.5;
        });
      }
      this.multipleChoiceOptions = options;
      this.notifyStateChange();
    }
  }, {
    key: "resetCards",
    value: function resetCards() {
      this.currentCard = 0;
      this.showAnswer = false;
      this.stats = {
        correct: 0,
        incorrect: 0,
        total: 0
      };
      this.selectedAnswer = null;
      this.typedAnswer = '';
      this.typingFeedback = '';
      if (this.autoAdvanceTimer) {
        clearTimeout(this.autoAdvanceTimer);
        this.autoAdvanceTimer = null;
      }
      this.notifyStateChange();
    }
  }, {
    key: "nextCard",
    value: function nextCard() {
      // Cancel any existing auto-advance timer
      if (this.autoAdvanceTimer) {
        clearTimeout(this.autoAdvanceTimer);
        this.autoAdvanceTimer = null;
      }
      this.currentCard = (this.currentCard + 1) % this.allWords.length;
      this.showAnswer = false;
      this.selectedAnswer = null;
      this.typedAnswer = '';
      this.typingFeedback = '';
      this.notifyStateChange();
    }
  }, {
    key: "prevCard",
    value: function prevCard() {
      // Cancel any existing auto-advance timer
      if (this.autoAdvanceTimer) {
        clearTimeout(this.autoAdvanceTimer);
        this.autoAdvanceTimer = null;
      }
      this.currentCard = (this.currentCard - 1 + this.allWords.length) % this.allWords.length;
      this.showAnswer = false;
      this.selectedAnswer = null;
      this.typedAnswer = '';
      this.typingFeedback = '';
      this.notifyStateChange();
    }

    // Methods to update stats only (for typing mode)
  }, {
    key: "updateStatsCorrect",
    value: function updateStatsCorrect() {
      this.stats = _objectSpread(_objectSpread({}, this.stats), {}, {
        correct: this.stats.correct + 1,
        total: this.stats.total + 1
      });
      this.notifyStateChange();
    }
  }, {
    key: "updateStatsIncorrect",
    value: function updateStatsIncorrect() {
      this.stats = _objectSpread(_objectSpread({}, this.stats), {}, {
        incorrect: this.stats.incorrect + 1,
        total: this.stats.total + 1
      });
      this.notifyStateChange();
    }
  }, {
    key: "markCorrect",
    value: function markCorrect(autoAdvance, defaultDelay) {
      var _this = this;
      this.stats = _objectSpread(_objectSpread({}, this.stats), {}, {
        correct: this.stats.correct + 1,
        total: this.stats.total + 1
      });
      if (autoAdvance) {
        var timerId = setTimeout(function () {
          _this.currentCard = (_this.currentCard + 1) % _this.allWords.length;
          _this.showAnswer = false;
          _this.selectedAnswer = null;
          _this.autoAdvanceTimer = null;
          _this.notifyStateChange();
        }, defaultDelay * 1000);
        this.autoAdvanceTimer = timerId;
      } else {
        this.currentCard = (this.currentCard + 1) % this.allWords.length;
        this.showAnswer = false;
        this.selectedAnswer = null;
      }
      this.notifyStateChange();
    }
  }, {
    key: "markIncorrect",
    value: function markIncorrect(autoAdvance, defaultDelay) {
      var _this2 = this;
      this.stats = _objectSpread(_objectSpread({}, this.stats), {}, {
        incorrect: this.stats.incorrect + 1,
        total: this.stats.total + 1
      });
      if (autoAdvance) {
        var timerId = setTimeout(function () {
          _this2.currentCard = (_this2.currentCard + 1) % _this2.allWords.length;
          _this2.showAnswer = false;
          _this2.selectedAnswer = null;
          _this2.autoAdvanceTimer = null;
          _this2.notifyStateChange();
        }, defaultDelay * 1000);
        this.autoAdvanceTimer = timerId;
      } else {
        this.currentCard = (this.currentCard + 1) % this.allWords.length;
        this.showAnswer = false;
        this.selectedAnswer = null;
      }
      this.notifyStateChange();
    }
  }, {
    key: "handleMultipleChoiceAnswer",
    value: function handleMultipleChoiceAnswer(selectedOption, studyMode, quizMode, autoAdvance, defaultDelay) {
      var _this3 = this;
      var currentWord = this.allWords[this.currentCard];
      var correctAnswer;
      if (quizMode === 'listening') {
        // In listening mode: LT->EN shows English options, LT->LT shows Lithuanian options
        correctAnswer = studyMode === 'lithuanian-to-english' ? currentWord.english : currentWord.lithuanian;
      } else {
        // Regular multiple choice mode
        correctAnswer = studyMode === 'english-to-lithuanian' ? currentWord.lithuanian : currentWord.english;
      }
      this.selectedAnswer = selectedOption;
      this.showAnswer = true;
      var isCorrect = selectedOption === correctAnswer;
      if (isCorrect) {
        this.stats = _objectSpread(_objectSpread({}, this.stats), {}, {
          correct: this.stats.correct + 1,
          total: this.stats.total + 1
        });
      } else {
        this.stats = _objectSpread(_objectSpread({}, this.stats), {}, {
          incorrect: this.stats.incorrect + 1,
          total: this.stats.total + 1
        });
      }
      if (autoAdvance) {
        var timerId = setTimeout(function () {
          _this3.currentCard = (_this3.currentCard + 1) % _this3.allWords.length;
          _this3.showAnswer = false;
          _this3.selectedAnswer = null;
          _this3.autoAdvanceTimer = null;
          _this3.notifyStateChange();
        }, defaultDelay * 1000);
        this.autoAdvanceTimer = timerId;
      }
      this.notifyStateChange();
    }
  }, {
    key: "setShowAnswer",
    value: function setShowAnswer(value) {
      this.showAnswer = value;
      this.notifyStateChange();
    }
  }, {
    key: "setTypedAnswer",
    value: function setTypedAnswer(value) {
      this.typedAnswer = value;
      this.notifyStateChange();
    }
  }, {
    key: "setTypingFeedback",
    value: function setTypingFeedback(value) {
      this.typingFeedback = value;
      this.notifyStateChange();
    }
  }, {
    key: "setAutoAdvanceTimer",
    value: function setAutoAdvanceTimer(timer) {
      this.autoAdvanceTimer = timer;
      this.notifyStateChange();
    }
  }, {
    key: "getCurrentWord",
    value: function getCurrentWord() {
      return this.allWords[this.currentCard];
    }
  }, {
    key: "getTotalWords",
    value: function getTotalWords() {
      return this.allWords.length;
    }
  }]);
}();
window.WordListManager = WordListManager;
;



"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
// import React from 'react';

var AudioButton = function AudioButton(_ref) {
  var word = _ref.word,
    _ref$size = _ref.size,
    size = _ref$size === void 0 ? 'normal' : _ref$size,
    audioEnabled = _ref.audioEnabled,
    playAudio = _ref.playAudio;
  // Define styles based on size
  var buttonStyle = {
    fontSize: size === 'small' ? '0.8rem' : size === 'large' ? '1.5rem' : '1rem',
    cursor: 'pointer',
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center'
  };

  // If audio is disabled, show muted icon
  if (!audioEnabled) {
    return /*#__PURE__*/React.createElement("span", {
      className: "w-audio-button w-audio-disabled",
      title: "Audio is disabled in settings",
      style: _objectSpread(_objectSpread({}, buttonStyle), {}, {
        opacity: 0.5
      })
    }, "\uD83D\uDD07");
  }
  return /*#__PURE__*/React.createElement("button", {
    className: "w-audio-button",
    onClick: function onClick(e) {
      e.stopPropagation();
      playAudio(word);
    },
    title: "Play pronunciation",
    style: buttonStyle
  }, "\uD83D\uDD0A");
};
window.AudioButton = AudioButton;
;



"use strict";

// import React from 'react';

var StatsDisplay = function StatsDisplay(_ref) {
  var stats = _ref.stats,
    onReset = _ref.onReset;
  return /*#__PURE__*/React.createElement("div", {
    className: "w-stats"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-stat-item"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-stat-value",
    style: {
      color: 'var(--color-success)'
    }
  }, stats.correct), /*#__PURE__*/React.createElement("div", {
    className: "w-stat-label"
  }, "Correct")), /*#__PURE__*/React.createElement("div", {
    className: "w-stat-item"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-stat-value",
    style: {
      color: 'var(--color-error)'
    }
  }, stats.incorrect), /*#__PURE__*/React.createElement("div", {
    className: "w-stat-label"
  }, "Incorrect")), /*#__PURE__*/React.createElement("div", {
    className: "w-stat-item"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-stat-value"
  }, stats.total > 0 ? Math.round(stats.correct / stats.total * 100) : 0, "%"), /*#__PURE__*/React.createElement("div", {
    className: "w-stat-label"
  }, "Accuracy")), /*#__PURE__*/React.createElement("button", {
    className: "w-button-secondary",
    onClick: onReset
  }, "\uD83D\uDD04 Reset"));
};
window.StatsDisplay = StatsDisplay;
;



"use strict";

// import React from 'react';
// import AudioButton from './AudioButton';

var MultipleChoiceOptions = function MultipleChoiceOptions(_ref) {
  var wordListManager = _ref.wordListManager,
    wordListState = _ref.wordListState,
    studyMode = _ref.studyMode,
    quizMode = _ref.quizMode,
    handleMultipleChoiceAnswer = _ref.handleMultipleChoiceAnswer,
    audioEnabled = _ref.audioEnabled,
    playAudio = _ref.playAudio,
    handleHoverStart = _ref.handleHoverStart,
    handleHoverEnd = _ref.handleHoverEnd;
  return /*#__PURE__*/React.createElement("div", {
    className: "w-multiple-choice"
  }, wordListState.multipleChoiceOptions.map(function (option, index) {
    var currentWord = wordListManager.getCurrentWord();
    if (!currentWord) return null;

    // Determine correct answer based on mode
    var correctAnswer;
    if (quizMode === 'listening') {
      correctAnswer = studyMode === 'lithuanian-to-english' ? currentWord.english : currentWord.lithuanian;
    } else {
      correctAnswer = studyMode === 'english-to-lithuanian' ? currentWord.lithuanian : currentWord.english;
    }
    var isCorrect = option === correctAnswer;
    var isSelected = option === wordListState.selectedAnswer;
    var className = 'w-choice-option';
    if (wordListState.showAnswer) {
      if (isCorrect) {
        className += ' w-correct';
      } else if (isSelected && !isCorrect) {
        className += ' w-incorrect';
      } else if (!isSelected) {
        className += ' w-unselected';
      }
    }

    // Find the translation for all options when showAnswer is true
    var translation = null;
    if (wordListState.showAnswer) {
      if (isCorrect) {
        // For correct answer, show the opposite translation
        translation = studyMode === 'lithuanian-to-english' ? currentWord.lithuanian : currentWord.english;
      } else {
        // For all other options, find the word that matches this option
        var matchingWord = wordListState.allWords.find(function (w) {
          return (studyMode === 'lithuanian-to-english' ? w.english : w.lithuanian) === option || (studyMode === 'english-to-lithuanian' ? w.lithuanian : w.english) === option;
        });
        if (matchingWord) {
          translation = studyMode === 'lithuanian-to-english' ? matchingWord.lithuanian : matchingWord.english;
        }
      }
    }
    var shouldShowAudioOnHover = audioEnabled && studyMode === 'english-to-lithuanian' && quizMode !== 'listening';
    var audioWord = option; // In EN->LT mode, options are Lithuanian words

    return /*#__PURE__*/React.createElement("button", {
      key: index,
      className: className,
      onClick: function onClick() {
        return !wordListState.showAnswer && handleMultipleChoiceAnswer(option);
      },
      onMouseEnter: function onMouseEnter() {
        return shouldShowAudioOnHover && handleHoverStart && handleHoverStart(audioWord);
      },
      onMouseLeave: function onMouseLeave() {
        return shouldShowAudioOnHover && handleHoverEnd && handleHoverEnd();
      },
      disabled: wordListState.showAnswer
    }, /*#__PURE__*/React.createElement("div", {
      className: "trakaido-choice-content"
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        textAlign: 'center'
      }
    }, /*#__PURE__*/React.createElement("span", null, option), /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: '0.8rem',
        marginTop: '4px',
        minHeight: '1.2em'
      }
    }, wordListState.showAnswer && translation && /*#__PURE__*/React.createElement("span", {
      style: {
        color: isCorrect || isSelected ? 'rgba(255,255,255,0.8)' : 'var(--color-text-secondary)'
      }
    }, "(", translation, ")"))), wordListState.showAnswer && isCorrect && /*#__PURE__*/React.createElement("div", {
      style: {
        display: 'inline-block',
        marginLeft: '8px'
      }
    }, /*#__PURE__*/React.createElement(AudioButton, {
      word: studyMode === 'english-to-lithuanian' ? option : currentWord.lithuanian,
      audioEnabled: audioEnabled,
      playAudio: playAudio
    }))));
  }));
};
window.MultipleChoiceOptions = MultipleChoiceOptions;
;



"use strict";

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
// import React from 'react';
// import AudioButton from './AudioButton';

var ConjugationTable = function ConjugationTable(_ref) {
  var verb = _ref.verb,
    conjugations = _ref.conjugations,
    audioEnabled = _ref.audioEnabled,
    playAudio = _ref.playAudio,
    handleHoverStart = _ref.handleHoverStart,
    handleHoverEnd = _ref.handleHoverEnd;
  var conjugationList = conjugations[verb];
  if (!conjugationList) return null;

  // Create a 3x3 grid for conjugations
  var conjugationGrid = {
    'I': null,
    'you(s.)': null,
    'he': null,
    'she': null,
    'it': null,
    'we': null,
    'you(pl.)': null,
    'they(m.)': null,
    'they(f.)': null
  };
  conjugationList.forEach(function (conj) {
    var pronoun = conj.english.split(' ')[0];
    conjugationGrid[pronoun] = conj;
  });
  return /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 'var(--spacing-base)'
    }
  }, /*#__PURE__*/React.createElement("h4", null, "Conjugation Table for \"", verb, "\""), /*#__PURE__*/React.createElement("table", {
    style: {
      width: '100%',
      borderCollapse: 'collapse',
      border: '1px solid var(--color-border)',
      marginTop: 'var(--spacing-small)'
    }
  }, /*#__PURE__*/React.createElement("thead", null, /*#__PURE__*/React.createElement("tr", {
    style: {
      background: 'var(--color-annotation-bg)'
    }
  }, /*#__PURE__*/React.createElement("th", {
    style: {
      padding: 'var(--spacing-small)',
      border: '1px solid var(--color-border)'
    }
  }, "Person"), /*#__PURE__*/React.createElement("th", {
    style: {
      padding: 'var(--spacing-small)',
      border: '1px solid var(--color-border)'
    }
  }, "English"), /*#__PURE__*/React.createElement("th", {
    style: {
      padding: 'var(--spacing-small)',
      border: '1px solid var(--color-border)'
    }
  }, "Lithuanian"), /*#__PURE__*/React.createElement("th", {
    style: {
      padding: 'var(--spacing-small)',
      border: '1px solid var(--color-border)'
    }
  }, "Audio"))), /*#__PURE__*/React.createElement("tbody", null, Object.entries(conjugationGrid).map(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
      pronoun = _ref3[0],
      conj = _ref3[1];
    if (!conj) return null;
    return /*#__PURE__*/React.createElement("tr", {
      key: pronoun
    }, /*#__PURE__*/React.createElement("td", {
      style: {
        padding: 'var(--spacing-small)',
        border: '1px solid var(--color-border)',
        fontWeight: 'bold'
      }
    }, pronoun), /*#__PURE__*/React.createElement("td", {
      style: {
        padding: 'var(--spacing-small)',
        border: '1px solid var(--color-border)'
      }
    }, conj.english), /*#__PURE__*/React.createElement("td", {
      style: {
        padding: 'var(--spacing-small)',
        border: '1px solid var(--color-border)',
        cursor: audioEnabled ? 'pointer' : 'default'
      },
      onMouseEnter: function onMouseEnter() {
        return audioEnabled && handleHoverStart(conj.lithuanian);
      },
      onMouseLeave: handleHoverEnd
    }, conj.lithuanian), /*#__PURE__*/React.createElement("td", {
      style: {
        padding: 'var(--spacing-small)',
        border: '1px solid var(--color-border)',
        textAlign: 'center'
      }
    }, /*#__PURE__*/React.createElement(AudioButton, {
      word: conj.lithuanian,
      size: "small",
      audioEnabled: audioEnabled,
      playAudio: playAudio
    })));
  }))));
};
window.ConjugationTable = ConjugationTable;
;



"use strict";

// import React from 'react';
// import AudioButton from './AudioButton';

var DeclensionTable = function DeclensionTable(_ref) {
  var noun = _ref.noun,
    declensions = _ref.declensions,
    audioEnabled = _ref.audioEnabled,
    playAudio = _ref.playAudio,
    handleHoverStart = _ref.handleHoverStart,
    handleHoverEnd = _ref.handleHoverEnd;
  var nounData = declensions[noun];
  if (!nounData) return null;
  var cases = ['nominative', 'genitive', 'dative', 'accusative', 'instrumental', 'locative', 'vocative'];
  return /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 'var(--spacing-base)'
    }
  }, /*#__PURE__*/React.createElement("h4", null, "Declension Table for \"", noun, "\" (", nounData.english, ")"), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: '0.9rem',
      color: 'var(--color-text-muted)',
      marginBottom: 'var(--spacing-small)'
    }
  }, "Gender: ", nounData.gender, " | Type: ", nounData.declension_type), /*#__PURE__*/React.createElement("table", {
    style: {
      width: '100%',
      borderCollapse: 'collapse',
      border: '1px solid var(--color-border)',
      marginTop: 'var(--spacing-small)'
    }
  }, /*#__PURE__*/React.createElement("thead", null, /*#__PURE__*/React.createElement("tr", {
    style: {
      background: 'var(--color-annotation-bg)'
    }
  }, /*#__PURE__*/React.createElement("th", {
    style: {
      padding: 'var(--spacing-small)',
      border: '1px solid var(--color-border)'
    }
  }, "Case"), /*#__PURE__*/React.createElement("th", {
    style: {
      padding: 'var(--spacing-small)',
      border: '1px solid var(--color-border)'
    }
  }, "Question"), /*#__PURE__*/React.createElement("th", {
    style: {
      padding: 'var(--spacing-small)',
      border: '1px solid var(--color-border)'
    }
  }, "Form"), /*#__PURE__*/React.createElement("th", {
    style: {
      padding: 'var(--spacing-small)',
      border: '1px solid var(--color-border)'
    }
  }, "Example"), /*#__PURE__*/React.createElement("th", {
    style: {
      padding: 'var(--spacing-small)',
      border: '1px solid var(--color-border)'
    }
  }, "Audio"))), /*#__PURE__*/React.createElement("tbody", null, cases.map(function (caseName) {
    var caseData = nounData.cases[caseName];
    if (!caseData) return null;
    return /*#__PURE__*/React.createElement("tr", {
      key: caseName
    }, /*#__PURE__*/React.createElement("td", {
      style: {
        padding: 'var(--spacing-small)',
        border: '1px solid var(--color-border)',
        fontWeight: 'bold',
        textTransform: 'capitalize'
      }
    }, caseName), /*#__PURE__*/React.createElement("td", {
      style: {
        padding: 'var(--spacing-small)',
        border: '1px solid var(--color-border)',
        fontSize: '0.85rem',
        fontStyle: 'italic'
      }
    }, caseData.question), /*#__PURE__*/React.createElement("td", {
      style: {
        padding: 'var(--spacing-small)',
        border: '1px solid var(--color-border)',
        fontWeight: 'bold',
        cursor: audioEnabled ? 'pointer' : 'default'
      },
      onMouseEnter: function onMouseEnter() {
        return audioEnabled && handleHoverStart(caseData.form);
      },
      onMouseLeave: handleHoverEnd
    }, caseData.form), /*#__PURE__*/React.createElement("td", {
      style: {
        padding: 'var(--spacing-small)',
        border: '1px solid var(--color-border)',
        fontSize: '0.9rem'
      }
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        marginBottom: '2px'
      }
    }, /*#__PURE__*/React.createElement("strong", null, "LT:"), " ", caseData.sentence_lithuanian), /*#__PURE__*/React.createElement("div", {
      style: {
        color: 'var(--color-text-muted)'
      }
    }, /*#__PURE__*/React.createElement("strong", null, "EN:"), " ", caseData.sentence_english)), /*#__PURE__*/React.createElement("td", {
      style: {
        padding: 'var(--spacing-small)',
        border: '1px solid var(--color-border)',
        textAlign: 'center'
      }
    }, /*#__PURE__*/React.createElement(AudioButton, {
      word: caseData.form,
      size: "small",
      audioEnabled: audioEnabled,
      playAudio: playAudio
    })));
  }))));
};
window.DeclensionTable = DeclensionTable;
;



"use strict";

// import React from 'react';

var SplashScreen = function SplashScreen() {
  return /*#__PURE__*/React.createElement("div", {
    className: "w-container"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-card",
    style: {
      textAlign: 'center',
      padding: 'var(--spacing-xlarge, 3rem)',
      marginTop: '20vh',
      background: 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)',
      border: '2px solid #dee2e6',
      boxShadow: '0 8px 32px rgba(0,0,0,0.1)'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: 'var(--spacing-large, 2rem)'
    }
  }, /*#__PURE__*/React.createElement("h1", {
    style: {
      fontSize: '3rem',
      margin: '0 0 0.5rem 0',
      color: '#2c3e50',
      fontWeight: 'bold',
      textShadow: '2px 2px 4px rgba(0,0,0,0.1)'
    }
  }, "\uD83C\uDDF1\uD83C\uDDF9 Trakaido"), /*#__PURE__*/React.createElement("p", {
    style: {
      fontSize: '1.5rem',
      margin: '0',
      color: '#6c757d',
      fontWeight: '300'
    }
  }, "Learn Lithuanian")), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: '0.8rem',
      color: '#adb5bd',
      marginTop: 'var(--spacing-large, 2rem)'
    }
  }, "\xA9 2025 Yevaud Platforms LLC. All rights reserved.")));
};
window.SplashScreen = SplashScreen;
;



"use strict";

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
// import React, { useState } from 'react';

var WelcomeScreen = function WelcomeScreen(_ref) {
  var onComplete = _ref.onComplete;
  var _useState = useState(''),
    _useState2 = _slicedToArray(_useState, 2),
    selectedLevel = _useState2[0],
    setSelectedLevel = _useState2[1];
  var handleContinue = function handleContinue() {
    if (selectedLevel) {
      onComplete(selectedLevel);
    }
  };
  return /*#__PURE__*/React.createElement("div", {
    className: "w-container"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-card",
    style: {
      textAlign: 'center',
      padding: 'var(--spacing-xlarge, 3rem)',
      marginTop: '10vh',
      background: 'linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%)',
      border: '2px solid #dee2e6',
      boxShadow: '0 8px 32px rgba(0,0,0,0.1)'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: 'var(--spacing-large, 2rem)'
    }
  }, /*#__PURE__*/React.createElement("h1", {
    style: {
      fontSize: '3rem',
      margin: '0 0 0.5rem 0',
      color: '#2c3e50',
      fontWeight: 'bold'
    }
  }, "\uD83C\uDDF1\uD83C\uDDF9 Welcome to Trakaido!"), /*#__PURE__*/React.createElement("p", {
    style: {
      fontSize: '1.2rem',
      margin: '0 0 2rem 0',
      color: '#6c757d',
      fontWeight: '300'
    }
  }, "Your Lithuanian Learning Companion")), /*#__PURE__*/React.createElement("div", {
    style: {
      textAlign: 'left',
      marginBottom: 'var(--spacing-large, 2rem)',
      padding: '0 1rem'
    }
  }, /*#__PURE__*/React.createElement("h3", {
    style: {
      color: '#2c3e50',
      marginBottom: '1rem'
    }
  }, "What can you do with Trakaido?"), /*#__PURE__*/React.createElement("ul", {
    style: {
      fontSize: '1.1rem',
      lineHeight: '1.6',
      color: '#495057',
      listStyle: 'none',
      padding: 0
    }
  }, /*#__PURE__*/React.createElement("li", {
    style: {
      marginBottom: '0.5rem'
    }
  }, "\uD83D\uDCDA ", /*#__PURE__*/React.createElement("strong", null, "Flash Cards:"), " Learn vocabulary with interactive cards"), /*#__PURE__*/React.createElement("li", {
    style: {
      marginBottom: '0.5rem'
    }
  }, "\u270F\uFE0F ", /*#__PURE__*/React.createElement("strong", null, "Multiple Choice:"), " Test your knowledge with quizzes"), /*#__PURE__*/React.createElement("li", {
    style: {
      marginBottom: '0.5rem'
    }
  }, "\u2328\uFE0F ", /*#__PURE__*/React.createElement("strong", null, "Typing Practice:"), " Improve spelling and recall"), /*#__PURE__*/React.createElement("li", {
    style: {
      marginBottom: '0.5rem'
    }
  }, "\uD83C\uDFA7 ", /*#__PURE__*/React.createElement("strong", null, "Listening Mode:"), " Train your ear with audio"), /*#__PURE__*/React.createElement("li", {
    style: {
      marginBottom: '0.5rem'
    }
  }, "\uD83D\uDCD6 ", /*#__PURE__*/React.createElement("strong", null, "Grammar:"), " Study verb conjugations and noun declensions"), /*#__PURE__*/React.createElement("li", {
    style: {
      marginBottom: '0.5rem'
    }
  }, "\uD83D\uDCD1 ", /*#__PURE__*/React.createElement("strong", null, "Vocabulary Lists:"), " Browse and study word collections"))), /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: 'var(--spacing-large, 2rem)'
    }
  }, /*#__PURE__*/React.createElement("h3", {
    style: {
      color: '#2c3e50',
      marginBottom: '1rem'
    }
  }, "What's your Lithuanian level?"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      flexDirection: 'column',
      gap: '0.75rem',
      alignItems: 'center'
    }
  }, /*#__PURE__*/React.createElement("label", {
    style: {
      display: 'flex',
      alignItems: 'center',
      cursor: 'pointer',
      padding: '0.75rem 1rem',
      border: "2px solid ".concat(selectedLevel === 'beginner' ? '#007bff' : '#dee2e6'),
      borderRadius: 'var(--border-radius)',
      background: selectedLevel === 'beginner' ? '#f8f9ff' : 'white',
      width: '300px',
      fontSize: '1.1rem'
    }
  }, /*#__PURE__*/React.createElement("input", {
    type: "radio",
    name: "level",
    value: "beginner",
    checked: selectedLevel === 'beginner',
    onChange: function onChange(e) {
      return setSelectedLevel(e.target.value);
    },
    style: {
      marginRight: '0.75rem'
    }
  }), /*#__PURE__*/React.createElement("span", null, "\uD83C\uDF31 ", /*#__PURE__*/React.createElement("strong", null, "Completely new to Lithuanian"))), /*#__PURE__*/React.createElement("label", {
    style: {
      display: 'flex',
      alignItems: 'center',
      cursor: 'pointer',
      padding: '0.75rem 1rem',
      border: "2px solid ".concat(selectedLevel === 'intermediate' ? '#007bff' : '#dee2e6'),
      borderRadius: 'var(--border-radius)',
      background: selectedLevel === 'intermediate' ? '#f8f9ff' : 'white',
      width: '300px',
      fontSize: '1.1rem'
    }
  }, /*#__PURE__*/React.createElement("input", {
    type: "radio",
    name: "level",
    value: "intermediate",
    checked: selectedLevel === 'intermediate',
    onChange: function onChange(e) {
      return setSelectedLevel(e.target.value);
    },
    style: {
      marginRight: '0.75rem'
    }
  }), /*#__PURE__*/React.createElement("span", null, "\uD83D\uDCDA ", /*#__PURE__*/React.createElement("strong", null, "Have some skill"))), /*#__PURE__*/React.createElement("label", {
    style: {
      display: 'flex',
      alignItems: 'center',
      cursor: 'pointer',
      padding: '0.75rem 1rem',
      border: "2px solid ".concat(selectedLevel === 'expert' ? '#007bff' : '#dee2e6'),
      borderRadius: 'var(--border-radius)',
      background: selectedLevel === 'expert' ? '#f8f9ff' : 'white',
      width: '300px',
      fontSize: '1.1rem'
    }
  }, /*#__PURE__*/React.createElement("input", {
    type: "radio",
    name: "level",
    value: "expert",
    checked: selectedLevel === 'expert',
    onChange: function onChange(e) {
      return setSelectedLevel(e.target.value);
    },
    style: {
      marginRight: '0.75rem'
    }
  }), /*#__PURE__*/React.createElement("span", null, "\uD83C\uDF93 ", /*#__PURE__*/React.createElement("strong", null, "Expert"))))), /*#__PURE__*/React.createElement("button", {
    onClick: handleContinue,
    disabled: !selectedLevel,
    className: "w-button",
    style: {
      padding: '1rem 2rem',
      fontSize: '1.2rem',
      fontWeight: 'bold',
      background: selectedLevel ? '#007bff' : '#6c757d',
      color: 'white',
      border: 'none',
      borderRadius: 'var(--border-radius)',
      cursor: selectedLevel ? 'pointer' : 'not-allowed',
      minWidth: '200px'
    }
  }, "Let's Start Learning! \uD83D\uDE80"), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: '0.8rem',
      color: '#adb5bd',
      marginTop: 'var(--spacing-large, 2rem)'
    }
  }, "\xA9 2025 Yevaud Platforms LLC. All rights reserved.")));
};
window.WelcomeScreen = WelcomeScreen;
;



"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
// import React from 'react';
// import AudioButton from './AudioButton';

var VocabularyList = function VocabularyList(_ref) {
  var selectedVocabGroup = _ref.selectedVocabGroup,
    setSelectedVocabGroup = _ref.setSelectedVocabGroup,
    vocabGroupOptions = _ref.vocabGroupOptions,
    vocabListWords = _ref.vocabListWords,
    setVocabListWords = _ref.setVocabListWords,
    corporaData = _ref.corporaData,
    audioEnabled = _ref.audioEnabled,
    playAudio = _ref.playAudio;
  var loadVocabListForGroup = function loadVocabListForGroup(optionValue) {
    var _corporaData$corpus;
    if (!optionValue) {
      setSelectedVocabGroup(null);
      setVocabListWords([]);
      return;
    }

    // Parse the combined value to get corpus and group
    var _optionValue$split = optionValue.split('|'),
      _optionValue$split2 = _slicedToArray(_optionValue$split, 2),
      corpus = _optionValue$split2[0],
      group = _optionValue$split2[1];
    if (!corpus || !group || !((_corporaData$corpus = corporaData[corpus]) !== null && _corporaData$corpus !== void 0 && _corporaData$corpus.groups[group])) return;
    setSelectedVocabGroup(optionValue);

    // Get words for this specific group
    var words = corporaData[corpus].groups[group].map(function (word) {
      return _objectSpread(_objectSpread({}, word), {}, {
        corpus: corpus,
        group: group
      });
    });

    // Sort alphabetically by Lithuanian word
    words.sort(function (a, b) {
      return a.lithuanian.localeCompare(b.lithuanian);
    });
    setVocabListWords(words);
  };
  return /*#__PURE__*/React.createElement("div", {
    className: "w-card"
  }, /*#__PURE__*/React.createElement("h3", null, "Lithuanian Vocabulary List"), /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: 'var(--spacing-base)'
    }
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "group-select",
    style: {
      marginRight: 'var(--spacing-small)'
    }
  }, "Select a vocabulary group:"), /*#__PURE__*/React.createElement("select", {
    id: "group-select",
    value: selectedVocabGroup || '',
    onChange: function onChange(e) {
      return loadVocabListForGroup(e.target.value);
    },
    className: "w-mode-option",
    style: {
      minWidth: '250px'
    }
  }, /*#__PURE__*/React.createElement("option", {
    value: ""
  }, "-- Select Group --"), vocabGroupOptions.map(function (option) {
    return /*#__PURE__*/React.createElement("option", {
      key: "".concat(option.corpus, "|").concat(option.group),
      value: "".concat(option.corpus, "|").concat(option.group)
    }, option.displayName, " (", option.wordCount, " words)");
  }))), selectedVocabGroup && /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("h4", null, vocabListWords.length, " Words"), /*#__PURE__*/React.createElement("div", {
    style: {
      maxHeight: '60vh',
      overflowY: 'auto',
      border: '1px solid var(--color-border)',
      borderRadius: 'var(--border-radius)',
      padding: 'var(--spacing-small)'
    }
  }, /*#__PURE__*/React.createElement("table", {
    style: {
      width: '100%',
      borderCollapse: 'collapse'
    }
  }, /*#__PURE__*/React.createElement("thead", null, /*#__PURE__*/React.createElement("tr", null, /*#__PURE__*/React.createElement("th", {
    style: {
      padding: 'var(--spacing-small)',
      borderBottom: '2px solid var(--color-border)',
      textAlign: 'left',
      position: 'sticky',
      top: 0,
      background: 'var(--color-card-bg)'
    }
  }, "Lithuanian"), /*#__PURE__*/React.createElement("th", {
    style: {
      padding: 'var(--spacing-small)',
      borderBottom: '2px solid var(--color-border)',
      textAlign: 'left',
      position: 'sticky',
      top: 0,
      background: 'var(--color-card-bg)'
    }
  }, "English"), /*#__PURE__*/React.createElement("th", {
    style: {
      padding: 'var(--spacing-small)',
      borderBottom: '2px solid var(--color-border)',
      textAlign: 'center',
      width: '60px',
      position: 'sticky',
      top: 0,
      background: 'var(--color-card-bg)'
    }
  }, "Audio"))), /*#__PURE__*/React.createElement("tbody", null, vocabListWords.map(function (word, index) {
    return /*#__PURE__*/React.createElement("tr", {
      key: index,
      style: {
        backgroundColor: index % 2 === 0 ? 'var(--color-card-bg)' : 'var(--color-card-bg-alt)'
      }
    }, /*#__PURE__*/React.createElement("td", {
      style: {
        padding: 'var(--spacing-small)',
        borderBottom: '1px solid var(--color-border)'
      }
    }, word.lithuanian), /*#__PURE__*/React.createElement("td", {
      style: {
        padding: 'var(--spacing-small)',
        borderBottom: '1px solid var(--color-border)'
      }
    }, word.english), /*#__PURE__*/React.createElement("td", {
      style: {
        padding: 'var(--spacing-small)',
        borderBottom: '1px solid var(--color-border)',
        textAlign: 'center'
      }
    }, /*#__PURE__*/React.createElement(AudioButton, {
      word: word.lithuanian,
      audioEnabled: audioEnabled,
      playAudio: playAudio
    })));
  }))))));
};
window.VocabularyList = VocabularyList;
;



"use strict";

// import React from 'react';
// import AudioButton from './AudioButton';

var TypingMode = function TypingMode(_ref) {
  var wordListManager = _ref.wordListManager,
    wordListState = _ref.wordListState,
    studyMode = _ref.studyMode,
    nextCard = _ref.nextCard,
    audioEnabled = _ref.audioEnabled,
    playAudio = _ref.playAudio,
    autoAdvance = _ref.autoAdvance,
    defaultDelay = _ref.defaultDelay;
  var currentWord = wordListManager.getCurrentWord();

  // Handle checking typed answer - always check against Lithuanian word
  var handleSubmit = function handleSubmit(e) {
    e.preventDefault();
    if (!currentWord || wordListState.showAnswer) return;
    var correctAnswer = studyMode === 'english-to-lithuanian' ? currentWord.lithuanian : currentWord.english;
    var isCorrect = wordListState.typedAnswer.trim().toLowerCase() === correctAnswer.toLowerCase();
    if (isCorrect) {
      wordListManager.setTypingFeedback('✅ Correct!');
      wordListManager.updateStatsCorrect();
    } else {
      wordListManager.setTypingFeedback("\u274C Incorrect. The answer is: ".concat(correctAnswer));
      wordListManager.updateStatsIncorrect();
    }
    wordListManager.setShowAnswer(true);
  };
  if (!currentWord) {
    return /*#__PURE__*/React.createElement("div", {
      className: "w-card"
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        textAlign: 'center',
        padding: 'var(--spacing-large)'
      }
    }, /*#__PURE__*/React.createElement("div", null, "Loading word...")));
  }
  return /*#__PURE__*/React.createElement("div", {
    className: "w-card"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-badge"
  }, currentWord.corpus, " \u2192 ", currentWord.group), /*#__PURE__*/React.createElement("div", {
    className: "w-word-display",
    style: {
      marginBottom: 'var(--spacing-base)'
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-question",
    style: {
      marginBottom: 'var(--spacing-small)'
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontWeight: 'bold'
    }
  }, "English:"), " ", currentWord.english), wordListState.showAnswer ? /*#__PURE__*/React.createElement("div", {
    className: "w-answer",
    style: {
      marginBottom: 'var(--spacing-base)'
    }
  }, /*#__PURE__*/React.createElement("span", {
    style: {
      fontWeight: 'bold'
    }
  }, "Lithuanian:"), " ", currentWord.lithuanian, /*#__PURE__*/React.createElement("span", {
    style: {
      marginLeft: '0.5rem'
    }
  }, /*#__PURE__*/React.createElement(AudioButton, {
    word: currentWord.lithuanian,
    audioEnabled: audioEnabled,
    playAudio: playAudio
  }))) : /*#__PURE__*/React.createElement("div", {
    className: "w-prompt",
    style: {
      marginBottom: 'var(--spacing-base)',
      color: 'var(--color-text-muted)',
      fontStyle: 'italic'
    }
  }, "Type the Lithuanian word (with proper accents)")), wordListState.showAnswer && /*#__PURE__*/React.createElement("div", {
    className: "w-feedback",
    style: {
      padding: 'var(--spacing-base)',
      marginBottom: 'var(--spacing-base)',
      borderRadius: 'var(--border-radius)',
      backgroundColor: wordListState.typingFeedback === '✅ Correct!' ? 'rgba(0, 128, 0, 0.1)' : 'rgba(255, 0, 0, 0.1)',
      border: "1px solid ".concat(wordListState.typingFeedback === '✅ Correct!' ? 'green' : 'red')
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontWeight: 'bold',
      marginBottom: 'var(--spacing-small)',
      color: wordListState.typingFeedback === '✅ Correct!' ? 'green' : 'red'
    }
  }, wordListState.typingFeedback, wordListState.typingFeedback === '✅ Correct!' && autoAdvance && wordListState.autoAdvanceTimer && /*#__PURE__*/React.createElement("span", {
    style: {
      marginLeft: '1rem',
      fontSize: '0.9rem',
      fontWeight: 'normal'
    }
  }, "(Next card in ", defaultDelay, "s...)")), /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("strong", null, "Your answer:"), " ", wordListState.typedAnswer), wordListState.typingFeedback !== '✅ Correct!' && /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("strong", null, "Correct answer:"), " ", currentWord.lithuanian)), /*#__PURE__*/React.createElement("div", {
    className: "w-typing-area",
    style: {
      marginBottom: 'var(--spacing-base)'
    }
  }, !wordListState.showAnswer ? /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      gap: 'var(--spacing-small)'
    }
  }, /*#__PURE__*/React.createElement("form", {
    onSubmit: handleSubmit
  }, /*#__PURE__*/React.createElement("input", {
    type: "text",
    value: wordListState.typedAnswer,
    onChange: function onChange(e) {
      return wordListManager.setTypedAnswer(e.target.value);
    },
    placeholder: "Type your answer...",
    className: "w-typing-input",
    disabled: wordListState.showAnswer,
    autoFocus: true
  }), /*#__PURE__*/React.createElement("button", {
    type: "submit",
    className: "w-button w-button-primary",
    disabled: wordListState.showAnswer || !wordListState.typedAnswer.trim()
  }, "Submit"))), /*#__PURE__*/React.createElement("div", {
    className: "w-character-helpers",
    style: {
      marginTop: 'var(--spacing-small)'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      color: 'var(--color-text-muted)',
      marginBottom: 'var(--spacing-small)',
      fontSize: '0.9rem'
    }
  }, "Special characters:"), /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      flexWrap: 'wrap',
      gap: '0.5rem'
    }
  }, ['ą', 'č', 'ę', 'ė', 'į', 'š', 'ų', 'ū', 'ž'].map(function (_char) {
    return /*#__PURE__*/React.createElement("button", {
      key: _char,
      className: "w-special-char",
      onClick: function onClick() {
        return wordListManager.setTypedAnswer(wordListState.typedAnswer + _char);
      },
      style: {
        padding: '0.5rem 0.7rem',
        borderRadius: 'var(--border-radius)',
        border: '1px solid var(--color-border)',
        background: 'var(--color-card-bg)',
        color: 'var(--color-text)',
        cursor: 'pointer',
        fontSize: '1.1rem',
        minWidth: '2.5rem'
      }
    }, _char);
  })))) : /*#__PURE__*/React.createElement("button", {
    className: "w-button",
    onClick: nextCard,
    style: {
      width: '100%'
    }
  }, "Next Word \u2192")));
};
window.TypingMode = TypingMode;
;



"use strict";

// import React from 'react';
// import AudioButton from './AudioButton';

var FlashCardMode = function FlashCardMode(_ref) {
  var currentWord = _ref.currentWord,
    showAnswer = _ref.showAnswer,
    setShowAnswer = _ref.setShowAnswer,
    studyMode = _ref.studyMode,
    audioEnabled = _ref.audioEnabled,
    playAudio = _ref.playAudio,
    handleHoverStart = _ref.handleHoverStart,
    handleHoverEnd = _ref.handleHoverEnd;
  if (!currentWord) return null;
  var question = studyMode === 'english-to-lithuanian' ? currentWord.english : currentWord.lithuanian;
  var answer = studyMode === 'english-to-lithuanian' ? currentWord.lithuanian : currentWord.english;
  return /*#__PURE__*/React.createElement("div", {
    className: "w-card w-card-interactive",
    onClick: function onClick() {
      return setShowAnswer(!showAnswer);
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-badge"
  }, currentWord.corpus, " \u2192 ", currentWord.group), /*#__PURE__*/React.createElement("div", {
    className: "w-question",
    onMouseEnter: function onMouseEnter() {
      return audioEnabled && studyMode === 'lithuanian-to-english' && handleHoverStart(question);
    },
    onMouseLeave: handleHoverEnd,
    style: {
      cursor: audioEnabled && studyMode === 'lithuanian-to-english' ? 'pointer' : 'default'
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'flex',
      alignItems: 'center',
      gap: '0.5rem',
      justifyContent: 'center'
    }
  }, /*#__PURE__*/React.createElement("span", null, question), studyMode === 'lithuanian-to-english' && /*#__PURE__*/React.createElement(AudioButton, {
    word: currentWord.lithuanian,
    audioEnabled: audioEnabled,
    playAudio: playAudio
  }))), showAnswer && /*#__PURE__*/React.createElement("div", {
    className: "trakaido-answer-text"
  }, /*#__PURE__*/React.createElement("span", null, answer), studyMode === 'english-to-lithuanian' && /*#__PURE__*/React.createElement(AudioButton, {
    word: currentWord.lithuanian,
    audioEnabled: audioEnabled,
    playAudio: playAudio
  })), !showAnswer && /*#__PURE__*/React.createElement("div", {
    style: {
      color: 'var(--color-text-muted)',
      fontSize: '0.9rem',
      marginTop: 'var(--spacing-base)'
    }
  }, "Click to reveal answer", audioEnabled && studyMode === 'lithuanian-to-english' && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: '0.8rem',
      marginTop: '0.25rem'
    }
  }, "(Hover over Lithuanian word to hear pronunciation)")));
};
window.FlashCardMode = FlashCardMode;
;



"use strict";

// import React from 'react';
// import MultipleChoiceOptions from './MultipleChoiceOptions';
// import AudioButton from './AudioButton';

var ListeningMode = function ListeningMode(_ref) {
  var wordListManager = _ref.wordListManager,
    wordListState = _ref.wordListState,
    studyMode = _ref.studyMode,
    audioEnabled = _ref.audioEnabled,
    playAudio = _ref.playAudio,
    handleMultipleChoiceAnswer = _ref.handleMultipleChoiceAnswer;
  var currentWord = wordListManager.getCurrentWord();
  if (!currentWord) return null;
  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
    className: "w-card"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-badge"
  }, currentWord.corpus, " \u2192 ", currentWord.group), /*#__PURE__*/React.createElement("div", {
    className: "w-question w-text-center"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-mb-large"
  }, "\uD83C\uDFA7 Listen and choose the correct answer:"), /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: 'var(--spacing-base)'
    }
  }, /*#__PURE__*/React.createElement(AudioButton, {
    word: currentWord.lithuanian,
    size: "large",
    audioEnabled: audioEnabled,
    playAudio: playAudio
  }), /*#__PURE__*/React.createElement("span", {
    style: {
      marginLeft: '0.5rem',
      fontSize: '1.2rem'
    }
  }, "Play Audio")), /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: '0.9rem',
      color: 'var(--color-text-muted)'
    }
  }, studyMode === 'lithuanian-to-english' ? 'Choose the English translation:' : 'Choose the matching Lithuanian word:'))), /*#__PURE__*/React.createElement(MultipleChoiceOptions, {
    wordListManager: wordListManager,
    wordListState: wordListState,
    studyMode: studyMode,
    quizMode: "listening",
    handleMultipleChoiceAnswer: handleMultipleChoiceAnswer,
    audioEnabled: audioEnabled,
    playAudio: playAudio
  }));
};
window.ListeningMode = ListeningMode;
;



"use strict";

// import React from 'react';
// import MultipleChoiceOptions from './MultipleChoiceOptions';

var MultipleChoiceMode = function MultipleChoiceMode(_ref) {
  var wordListManager = _ref.wordListManager,
    wordListState = _ref.wordListState,
    studyMode = _ref.studyMode,
    audioEnabled = _ref.audioEnabled,
    playAudio = _ref.playAudio,
    handleHoverStart = _ref.handleHoverStart,
    handleHoverEnd = _ref.handleHoverEnd,
    handleMultipleChoiceAnswer = _ref.handleMultipleChoiceAnswer;
  var currentWord = wordListManager.getCurrentWord();
  if (!currentWord) return null;
  var question = studyMode === 'english-to-lithuanian' ? currentWord.english : currentWord.lithuanian;
  return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
    className: "w-card"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-badge w-hide-mobile"
  }, currentWord.corpus, " \u2192 ", currentWord.group), /*#__PURE__*/React.createElement("div", {
    className: "w-question",
    onMouseEnter: function onMouseEnter() {
      return audioEnabled && studyMode === 'lithuanian-to-english' && handleHoverStart(question);
    },
    onMouseLeave: handleHoverEnd,
    style: {
      cursor: audioEnabled && studyMode === 'lithuanian-to-english' ? 'pointer' : 'default'
    }
  }, question), /*#__PURE__*/React.createElement("div", {
    className: "w-hide-mobile",
    style: {
      color: 'var(--color-text-muted)',
      fontSize: '0.9rem',
      marginTop: 'var(--spacing-base)'
    }
  }, "Choose the correct answer:", audioEnabled && /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: '0.8rem',
      marginTop: '0.25rem'
    }
  }, studyMode === 'lithuanian-to-english' ? '(Hover over Lithuanian words for 0.9 seconds to hear pronunciation)' : '(Hover over answer choices for 0.9 seconds to hear pronunciation)'))), /*#__PURE__*/React.createElement(MultipleChoiceOptions, {
    wordListManager: wordListManager,
    wordListState: wordListState,
    studyMode: studyMode,
    quizMode: "multiple-choice",
    handleMultipleChoiceAnswer: handleMultipleChoiceAnswer,
    audioEnabled: audioEnabled,
    playAudio: playAudio,
    handleHoverStart: handleHoverStart,
    handleHoverEnd: handleHoverEnd
  }));
};
window.MultipleChoiceMode = MultipleChoiceMode;
;



"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
// import React, { useState, useRef, useEffect } from 'react';

var StudyMaterialsModal = function StudyMaterialsModal(_ref) {
  var isOpen = _ref.isOpen,
    onClose = _ref.onClose,
    totalSelectedWords = _ref.totalSelectedWords,
    availableCorpora = _ref.availableCorpora,
    corporaData = _ref.corporaData,
    selectedGroups = _ref.selectedGroups,
    setSelectedGroups = _ref.setSelectedGroups,
    resetAllSettings = _ref.resetAllSettings,
    safeStorage = _ref.safeStorage;
  var modalRef = useRef(null);
  var toggleGroup = function toggleGroup(corpus, group) {
    setSelectedGroups(function (prev) {
      var currentGroups = prev[corpus] || [];
      var newGroups = currentGroups.includes(group) ? currentGroups.filter(function (g) {
        return g !== group;
      }) : [].concat(_toConsumableArray(currentGroups), [group]);
      safeStorage.setItem('flashcard-selected-groups', JSON.stringify(_objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, corpus, newGroups))));
      return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, corpus, newGroups));
    });
  };
  var toggleCorpus = function toggleCorpus(corpus) {
    setSelectedGroups(function (prev) {
      var _corporaData$corpus;
      var allGroups = Object.keys(((_corporaData$corpus = corporaData[corpus]) === null || _corporaData$corpus === void 0 ? void 0 : _corporaData$corpus.groups) || {});
      var currentGroups = prev[corpus] || [];
      var allSelected = allGroups.length > 0 && allGroups.every(function (g) {
        return currentGroups.includes(g);
      });
      var newGroups = allSelected ? [] : allGroups;
      safeStorage.setItem('flashcard-selected-groups', JSON.stringify(_objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, corpus, newGroups))));
      return _objectSpread(_objectSpread({}, prev), {}, _defineProperty({}, corpus, newGroups));
    });
  };

  // Handle escape key and outside clicks
  useEffect(function () {
    var handleKeyDown = function handleKeyDown(event) {
      if (event.key === 'Escape' && isOpen) {
        onClose();
      }
    };
    var handleClickOutside = function handleClickOutside(event) {
      if (modalRef.current && event.target && !modalRef.current.contains(event.target)) {
        onClose();
      }
    };
    if (isOpen) {
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('mousedown', handleClickOutside);
    }
    return function () {
      document.removeEventListener('keydown', handleKeyDown);
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen, onClose]);
  if (!isOpen) return null;
  return /*#__PURE__*/React.createElement("div", {
    className: "w-settings-overlay"
  }, /*#__PURE__*/React.createElement("div", {
    ref: modalRef,
    className: "w-settings-modal"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-settings-header"
  }, /*#__PURE__*/React.createElement("h2", {
    className: "w-settings-title"
  }, "Study Materials (", totalSelectedWords, " words selected)"), /*#__PURE__*/React.createElement("button", {
    onClick: onClose,
    className: "w-settings-close",
    "aria-label": "Close study materials"
  }, "\xD7")), /*#__PURE__*/React.createElement("div", {
    className: "w-settings-form",
    style: {
      maxHeight: '60vh',
      overflowY: 'auto'
    }
  }, availableCorpora.map(function (corpus) {
    var corporaStructure = corporaData[corpus];
    if (!corporaStructure) return null;
    var groups = Object.keys(corporaStructure.groups);
    var selectedCorpusGroups = selectedGroups[corpus] || [];
    var allSelected = groups.length > 0 && groups.every(function (g) {
      return selectedCorpusGroups.includes(g);
    });
    var wordCount = selectedCorpusGroups.reduce(function (total, g) {
      var _corporaStructure$gro;
      return total + (((_corporaStructure$gro = corporaStructure.groups[g]) === null || _corporaStructure$gro === void 0 ? void 0 : _corporaStructure$gro.length) || 0);
    }, 0);
    return /*#__PURE__*/React.createElement("div", {
      key: corpus,
      className: "trakaido-corpus-section"
    }, /*#__PURE__*/React.createElement("div", {
      className: "trakaido-corpus-header",
      onClick: function onClick() {
        return toggleCorpus(corpus);
      }
    }, /*#__PURE__*/React.createElement("div", null, "\uD83D\uDCDA ", corpus, " (", wordCount, " words from ", selectedCorpusGroups.length, "/", groups.length, " groups)"), /*#__PURE__*/React.createElement("button", {
      className: "trakaido-corpus-toggle"
    }, allSelected ? 'Deselect All' : 'Select All')), /*#__PURE__*/React.createElement("div", {
      className: "trakaido-group-grid"
    }, groups.map(function (group) {
      var _corporaStructure$gro2;
      var groupWordCount = ((_corporaStructure$gro2 = corporaStructure.groups[group]) === null || _corporaStructure$gro2 === void 0 ? void 0 : _corporaStructure$gro2.length) || 0;
      var isSelected = selectedCorpusGroups.includes(group);
      return /*#__PURE__*/React.createElement("div", {
        key: group,
        className: "trakaido-group-item"
      }, /*#__PURE__*/React.createElement("input", {
        type: "checkbox",
        id: "".concat(corpus, "-").concat(group),
        checked: isSelected,
        onChange: function onChange() {
          return toggleGroup(corpus, group);
        }
      }), /*#__PURE__*/React.createElement("label", {
        htmlFor: "".concat(corpus, "-").concat(group),
        style: {
          fontSize: '0.9rem'
        }
      }, group, " (", groupWordCount, " words)"));
    })));
  }), /*#__PURE__*/React.createElement("button", {
    className: "w-mode-option w-compact-button",
    onClick: resetAllSettings,
    title: "Reset all local settings including selected corpuses"
  }, /*#__PURE__*/React.createElement("span", null, "\uD83D\uDD04 Reset Local Settings"))), /*#__PURE__*/React.createElement("div", {
    className: "w-settings-actions"
  }, /*#__PURE__*/React.createElement("button", {
    onClick: onClose,
    className: "w-settings-button w-settings-button-primary"
  }, "Done"))));
};
window.StudyMaterialsModal = StudyMaterialsModal;
;



"use strict";

var StudyModeSelector = function StudyModeSelector(_ref) {
  var quizMode = _ref.quizMode,
    setQuizMode = _ref.setQuizMode,
    grammarMode = _ref.grammarMode,
    setGrammarMode = _ref.setGrammarMode,
    studyMode = _ref.studyMode,
    setStudyMode = _ref.setStudyMode,
    safeStorage = _ref.safeStorage,
    SettingsToggle = _ref.SettingsToggle,
    audioEnabled = _ref.audioEnabled,
    availableVoices = _ref.availableVoices,
    selectedVoice = _ref.selectedVoice,
    setSelectedVoice = _ref.setSelectedVoice,
    isFullscreen = _ref.isFullscreen,
    toggleFullscreen = _ref.toggleFullscreen,
    totalSelectedWords = _ref.totalSelectedWords,
    onOpenStudyMaterials = _ref.onOpenStudyMaterials;
  return /*#__PURE__*/React.createElement("div", {
    className: "w-mode-selector"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-dropdown-container",
    style: {
      display: 'flex',
      flexDirection: 'column',
      gap: '0.5rem',
      margin: '0 0.5rem'
    }
  }, /*#__PURE__*/React.createElement("label", {
    className: "w-hide-mobile",
    style: {
      fontWeight: 'bold',
      fontSize: '0.9rem'
    }
  }, "Mode:"), /*#__PURE__*/React.createElement("select", {
    style: {
      padding: '0.5rem',
      borderRadius: 'var(--border-radius)',
      border: '1px solid var(--color-border)',
      background: 'var(--color-card-bg)',
      minHeight: '44px',
      cursor: 'pointer',
      fontSize: '0.9rem'
    },
    value: quizMode === 'conjugations' || quizMode === 'declensions' ? 'grammar' : quizMode,
    onChange: function onChange(e) {
      var selectedMode = e.target.value;
      if (selectedMode === 'grammar') {
        setQuizMode(grammarMode);
      } else {
        setQuizMode(selectedMode);
      }
      safeStorage.setItem('flashcard-quiz-mode', selectedMode === 'grammar' ? grammarMode : selectedMode);
    }
  }, /*#__PURE__*/React.createElement("option", {
    value: "flashcard"
  }, "Flash Cards"), /*#__PURE__*/React.createElement("option", {
    value: "multiple-choice"
  }, "Multiple Choice"), /*#__PURE__*/React.createElement("option", {
    value: "typing"
  }, "\u2328\uFE0F Typing"), /*#__PURE__*/React.createElement("option", {
    value: "listening"
  }, "\uD83C\uDFA7 Listening"), /*#__PURE__*/React.createElement("option", {
    value: "vocabulary-list"
  }, "\uD83D\uDCD1 Vocabulary List"), /*#__PURE__*/React.createElement("option", {
    value: "journey"
  }, "\uD83D\uDE80 Journey Mode"), /*#__PURE__*/React.createElement("option", {
    value: "grammar"
  }, "Grammar"))), /*#__PURE__*/React.createElement("div", {
    className: "w-dropdown-container",
    style: {
      display: 'flex',
      flexDirection: 'column',
      gap: '0.5rem',
      margin: '0 0.5rem'
    }
  }, /*#__PURE__*/React.createElement("label", {
    style: {
      fontWeight: 'bold',
      fontSize: '0.9rem'
    }
  }, quizMode === 'conjugations' || quizMode === 'declensions' ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
    className: "w-hide-mobile"
  }, "Grammar Type:"), /*#__PURE__*/React.createElement("span", {
    className: "w-show-mobile"
  }, "Grammar:")) : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
    className: "w-hide-mobile"
  }, "Direction:"), /*#__PURE__*/React.createElement("span", {
    className: "w-show-mobile",
    style: {
      display: 'none'
    }
  }, "Direction:"))), quizMode === 'conjugations' || quizMode === 'declensions' ? /*#__PURE__*/React.createElement("select", {
    style: {
      padding: '0.5rem',
      borderRadius: 'var(--border-radius)',
      border: '1px solid var(--color-border)',
      background: 'var(--color-card-bg)',
      minHeight: '44px',
      cursor: 'pointer',
      fontSize: '0.9rem'
    },
    value: quizMode,
    onChange: function onChange(e) {
      var selectedGrammarMode = e.target.value;
      setQuizMode(selectedGrammarMode);
      setGrammarMode(selectedGrammarMode);
      safeStorage.setItem('flashcard-quiz-mode', selectedGrammarMode);
    }
  }, /*#__PURE__*/React.createElement("option", {
    value: "conjugations"
  }, "\uD83D\uDCD6 Conjugations"), /*#__PURE__*/React.createElement("option", {
    value: "declensions"
  }, "\uD83D\uDCCB Declensions")) : /*#__PURE__*/React.createElement("select", {
    style: {
      padding: '0.5rem',
      borderRadius: 'var(--border-radius)',
      border: '1px solid var(--color-border)',
      background: 'var(--color-card-bg)',
      minHeight: '44px',
      cursor: 'pointer',
      fontSize: '0.9rem'
    },
    value: studyMode,
    onChange: function onChange(e) {
      setStudyMode(e.target.value);
      safeStorage.setItem('flashcard-study-mode', e.target.value);
    }
  }, /*#__PURE__*/React.createElement("option", {
    value: "english-to-lithuanian"
  }, "\uD83C\uDDFA\uD83C\uDDF8 \u2192 \uD83C\uDDF1\uD83C\uDDF9"), /*#__PURE__*/React.createElement("option", {
    value: "lithuanian-to-english"
  }, "\uD83C\uDDF1\uD83C\uDDF9 \u2192 \uD83C\uDDFA\uD83C\uDDF8"))), /*#__PURE__*/React.createElement("div", {
    className: "w-button-group-mobile"
  }, /*#__PURE__*/React.createElement("button", {
    className: "w-mode-option w-compact-button",
    onClick: onOpenStudyMaterials,
    title: "Select study materials and vocabulary groups"
  }, /*#__PURE__*/React.createElement("span", {
    className: "w-hide-mobile"
  }, "\uD83D\uDCDA Study Materials"), /*#__PURE__*/React.createElement("span", {
    className: "w-show-mobile"
  }, "\uD83D\uDCDA Materials")), /*#__PURE__*/React.createElement(SettingsToggle, {
    className: "w-mode-option w-compact-button",
    title: "Settings"
  }, /*#__PURE__*/React.createElement("span", {
    className: "w-hide-mobile"
  }, "Settings")), /*#__PURE__*/React.createElement("button", {
    className: "w-hide-mobile w-mode-option w-compact-button",
    onClick: toggleFullscreen
  }, isFullscreen ? '🗗 Close Fullscreen' : '⛶ Fullscreen')), audioEnabled && availableVoices.length > 0 && /*#__PURE__*/React.createElement("select", {
    value: selectedVoice || '',
    onChange: function onChange(e) {
      return setSelectedVoice(e.target.value);
    },
    className: "w-mode-option"
  }, /*#__PURE__*/React.createElement("option", {
    value: "random"
  }, "\uD83C\uDFB2 Random Voice"), availableVoices.map(function (voice) {
    return /*#__PURE__*/React.createElement("option", {
      key: voice,
      value: voice
    }, "\uD83C\uDFA4 ", voice);
  })));
};
window.StudyModeSelector = StudyModeSelector;
;



"use strict";

// import React from 'react';
// import ConjugationTable from './ConjugationTable';

var ConjugationsMode = function ConjugationsMode(_ref) {
  var selectedVerbCorpus = _ref.selectedVerbCorpus,
    setSelectedVerbCorpus = _ref.setSelectedVerbCorpus,
    availableVerbCorpuses = _ref.availableVerbCorpuses,
    loadingConjugations = _ref.loadingConjugations,
    selectedVerb = _ref.selectedVerb,
    setSelectedVerb = _ref.setSelectedVerb,
    availableVerbs = _ref.availableVerbs,
    conjugations = _ref.conjugations,
    audioEnabled = _ref.audioEnabled,
    playAudio = _ref.playAudio,
    handleHoverStart = _ref.handleHoverStart,
    handleHoverEnd = _ref.handleHoverEnd;
  return /*#__PURE__*/React.createElement("div", {
    className: "w-card"
  }, /*#__PURE__*/React.createElement("h3", null, "Lithuanian Verb Conjugations"), /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: 'var(--spacing-base)'
    }
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "corpus-select",
    style: {
      marginRight: 'var(--spacing-small)'
    }
  }, "Verb tense:"), /*#__PURE__*/React.createElement("select", {
    id: "corpus-select",
    value: selectedVerbCorpus,
    onChange: function onChange(e) {
      return setSelectedVerbCorpus(e.target.value);
    },
    disabled: loadingConjugations,
    className: "w-mode-option",
    style: {
      minWidth: '150px',
      marginRight: 'var(--spacing-base)'
    }
  }, availableVerbCorpuses.map(function (corpus) {
    return /*#__PURE__*/React.createElement("option", {
      key: corpus,
      value: corpus
    }, corpus === 'verbs_present' ? 'Present Tense' : corpus === 'verbs_past' ? 'Past Tense' : corpus.replace('verbs_', '').replace('_', ' '));
  })), loadingConjugations && /*#__PURE__*/React.createElement("span", {
    style: {
      fontSize: '0.8rem',
      color: 'var(--color-text-secondary)'
    }
  }, "Loading...")), /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: 'var(--spacing-base)'
    }
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "verb-select",
    style: {
      marginRight: 'var(--spacing-small)'
    }
  }, "Select a verb:"), /*#__PURE__*/React.createElement("select", {
    id: "verb-select",
    value: selectedVerb || '',
    onChange: function onChange(e) {
      return setSelectedVerb(e.target.value);
    },
    disabled: loadingConjugations || availableVerbs.length === 0,
    className: "w-mode-option",
    style: {
      minWidth: '150px'
    }
  }, /*#__PURE__*/React.createElement("option", {
    value: ""
  }, "Choose a verb..."), availableVerbs.map(function (verb) {
    return /*#__PURE__*/React.createElement("option", {
      key: verb,
      value: verb
    }, verb);
  }))), selectedVerb && /*#__PURE__*/React.createElement(ConjugationTable, {
    verb: selectedVerb,
    conjugations: conjugations,
    audioEnabled: audioEnabled,
    playAudio: playAudio,
    handleHoverStart: handleHoverStart,
    handleHoverEnd: handleHoverEnd
  }));
};
window.ConjugationsMode = ConjugationsMode;
;



"use strict";

// import React from 'react';
// import DeclensionTable from './DeclensionTable';

var DeclensionsMode = function DeclensionsMode(_ref) {
  var selectedNoun = _ref.selectedNoun,
    setSelectedNoun = _ref.setSelectedNoun,
    availableNouns = _ref.availableNouns,
    declensions = _ref.declensions,
    audioEnabled = _ref.audioEnabled,
    playAudio = _ref.playAudio,
    handleHoverStart = _ref.handleHoverStart,
    handleHoverEnd = _ref.handleHoverEnd;
  return /*#__PURE__*/React.createElement("div", {
    className: "w-card"
  }, /*#__PURE__*/React.createElement("h3", null, "Lithuanian Noun Declensions"), /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: 'var(--spacing-base)'
    }
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "noun-select",
    style: {
      marginRight: 'var(--spacing-small)'
    }
  }, "Select a noun:"), /*#__PURE__*/React.createElement("select", {
    id: "noun-select",
    value: selectedNoun || '',
    onChange: function onChange(e) {
      return setSelectedNoun(e.target.value);
    },
    className: "w-mode-option",
    style: {
      minWidth: '150px'
    }
  }, /*#__PURE__*/React.createElement("option", {
    value: ""
  }, "Choose a noun..."), availableNouns.map(function (noun) {
    var _declensions$noun;
    return /*#__PURE__*/React.createElement("option", {
      key: noun,
      value: noun
    }, noun, " (", ((_declensions$noun = declensions[noun]) === null || _declensions$noun === void 0 ? void 0 : _declensions$noun.english) || '', ")");
  }))), selectedNoun && /*#__PURE__*/React.createElement(DeclensionTable, {
    noun: selectedNoun,
    declensions: declensions,
    audioEnabled: audioEnabled,
    playAudio: playAudio,
    handleHoverStart: handleHoverStart,
    handleHoverEnd: handleHoverEnd
  }));
};
window.DeclensionsMode = DeclensionsMode;
;



"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
// import React from 'react';
// import FlashCardMode from './FlashCardMode';
// import MultipleChoiceMode from './MultipleChoiceMode';
// import ListeningMode from './ListeningMode';
// import AudioButton from './AudioButton';

var JourneyMode = function JourneyMode(_ref) {
  var wordListManager = _ref.wordListManager,
    wordListState = _ref.wordListState,
    studyMode = _ref.studyMode,
    audioEnabled = _ref.audioEnabled,
    playAudio = _ref.playAudio,
    handleHoverStart = _ref.handleHoverStart,
    handleHoverEnd = _ref.handleHoverEnd,
    handleMultipleChoiceAnswer = _ref.handleMultipleChoiceAnswer,
    nextCard = _ref.nextCard,
    autoAdvance = _ref.autoAdvance,
    defaultDelay = _ref.defaultDelay,
    safeStorage = _ref.safeStorage;
  // Core state - single source of truth
  var _React$useState = React.useState({
      isInitialized: false,
      currentActivity: null,
      currentWord: null,
      showNewWordIndicator: false
    }),
    _React$useState2 = _slicedToArray(_React$useState, 2),
    journeyState = _React$useState2[0],
    setJourneyState = _React$useState2[1];
  var _React$useState3 = React.useState({}),
    _React$useState4 = _slicedToArray(_React$useState3, 2),
    journeyStats = _React$useState4[0],
    setJourneyStats = _React$useState4[1];

  // Database connection
  var _React$useState5 = React.useState(null),
    _React$useState6 = _slicedToArray(_React$useState5, 2),
    db = _React$useState6[0],
    setDb = _React$useState6[1];

  // Initialize IndexedDB once
  React.useEffect(function () {
    var initDB = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              if (window.indexedDB) {
                _context.n = 1;
                break;
              }
              console.warn('IndexedDB not supported, falling back to localStorage');
              return _context.a(2, null);
            case 1:
              return _context.a(2, new Promise(function (resolve) {
                var request = indexedDB.open('JourneyModeDB', 1);
                request.onerror = function () {
                  console.error('IndexedDB error:', request.error);
                  resolve(null);
                };
                request.onsuccess = function () {
                  return resolve(request.result);
                };
                request.onupgradeneeded = function (event) {
                  var database = event.target.result;
                  if (!database.objectStoreNames.contains('wordStats')) {
                    database.createObjectStore('wordStats', {
                      keyPath: 'wordKey'
                    });
                  }
                };
              }));
          }
        }, _callee);
      }));
      return function initDB() {
        return _ref2.apply(this, arguments);
      };
    }();
    initDB().then(setDb);
  }, []);

  // Load stats once when DB is ready
  React.useEffect(function () {
    if (db === null) return; // Still initializing

    var loadStats = /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var transaction, store, request;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              if (db) {
                try {
                  transaction = db.transaction(['wordStats'], 'readonly');
                  store = transaction.objectStore('wordStats');
                  request = store.getAll();
                  request.onsuccess = function () {
                    var stats = {};
                    request.result.forEach(function (item) {
                      stats[item.wordKey] = item.stats;
                    });
                    setJourneyStats(stats);
                    setJourneyState(function (prev) {
                      return _objectSpread(_objectSpread({}, prev), {}, {
                        isInitialized: true
                      });
                    });
                  };
                  request.onerror = function () {
                    console.error('Error loading from IndexedDB, falling back to localStorage');
                    loadFromLocalStorage();
                  };
                } catch (error) {
                  console.error('IndexedDB error:', error);
                  loadFromLocalStorage();
                }
              } else {
                loadFromLocalStorage();
              }
            case 1:
              return _context2.a(2);
          }
        }, _callee2);
      }));
      return function loadStats() {
        return _ref3.apply(this, arguments);
      };
    }();
    var loadFromLocalStorage = function loadFromLocalStorage() {
      var savedStats = safeStorage === null || safeStorage === void 0 ? void 0 : safeStorage.getItem('journey-stats');
      try {
        setJourneyStats(savedStats ? JSON.parse(savedStats) : {});
        setJourneyState(function (prev) {
          return _objectSpread(_objectSpread({}, prev), {}, {
            isInitialized: true
          });
        });
      } catch (error) {
        console.error('Error parsing journey stats:', error);
        setJourneyStats({});
        setJourneyState(function (prev) {
          return _objectSpread(_objectSpread({}, prev), {}, {
            isInitialized: true
          });
        });
      }
    };
    loadStats();
  }, [db, safeStorage]);

  // Save stats function
  var saveStats = React.useCallback(/*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3(newStats) {
      var transaction, store;
      return _regenerator().w(function (_context3) {
        while (1) switch (_context3.n) {
          case 0:
            setJourneyStats(newStats);
            if (db) {
              try {
                transaction = db.transaction(['wordStats'], 'readwrite');
                store = transaction.objectStore('wordStats');
                store.clear();
                Object.entries(newStats).forEach(function (_ref5) {
                  var _ref6 = _slicedToArray(_ref5, 2),
                    wordKey = _ref6[0],
                    wordStats = _ref6[1];
                  store.add({
                    wordKey: wordKey,
                    stats: wordStats
                  });
                });
                transaction.onerror = function () {
                  console.error('Error saving to IndexedDB, falling back to localStorage');
                  safeStorage === null || safeStorage === void 0 || safeStorage.setItem('journey-stats', JSON.stringify(newStats));
                };
              } catch (error) {
                console.error('IndexedDB error:', error);
                safeStorage === null || safeStorage === void 0 || safeStorage.setItem('journey-stats', JSON.stringify(newStats));
              }
            } else {
              safeStorage === null || safeStorage === void 0 || safeStorage.setItem('journey-stats', JSON.stringify(newStats));
            }
          case 1:
            return _context3.a(2);
        }
      }, _callee3);
    }));
    return function (_x) {
      return _ref4.apply(this, arguments);
    };
  }(), [db, safeStorage]);

  // Helper functions for word categorization
  var getWordStats = React.useCallback(function (word) {
    var wordKey = "".concat(word.lithuanian, "-").concat(word.english);
    return journeyStats[wordKey] || {
      exposed: false,
      multipleChoice: {
        correct: 0,
        incorrect: 0
      },
      listening: {
        correct: 0,
        incorrect: 0
      },
      typing: {
        correct: 0,
        incorrect: 0
      },
      lastSeen: null
    };
  }, [journeyStats]);
  var getExposedWords = React.useCallback(function () {
    return wordListState.allWords.filter(function (word) {
      return getWordStats(word).exposed;
    });
  }, [wordListState.allWords, getWordStats]);
  var getNewWords = React.useCallback(function () {
    return wordListState.allWords.filter(function (word) {
      return !getWordStats(word).exposed;
    });
  }, [wordListState.allWords, getWordStats]);

  // Activity selection algorithm
  var selectNextActivity = React.useCallback(function () {
    var exposedWords = getExposedWords();
    var newWords = getNewWords();
    if (wordListState.allWords.length === 0) {
      return {
        type: 'new-word',
        word: wordListManager.getCurrentWord()
      };
    }

    // If fewer than 10 known words, always show new word
    if (exposedWords.length < 10 && newWords.length > 0) {
      var randomNewWord = newWords[Math.floor(Math.random() * newWords.length)];
      return {
        type: 'new-word',
        word: randomNewWord
      };
    }
    var random = Math.random() * 100;
    if (random < 20 && newWords.length > 0) {
      var _randomNewWord = newWords[Math.floor(Math.random() * newWords.length)];
      return {
        type: 'new-word',
        word: _randomNewWord
      };
    } else if (random < 50 && exposedWords.length > 0) {
      var randomExposedWord = exposedWords[Math.floor(Math.random() * exposedWords.length)];
      return {
        type: 'multiple-choice',
        word: randomExposedWord
      };
    } else if (random < 80 && exposedWords.length > 0) {
      var _randomExposedWord = exposedWords[Math.floor(Math.random() * exposedWords.length)];
      return {
        type: 'listening',
        word: _randomExposedWord
      };
    } else if (random < 97 && exposedWords.length > 0) {
      var _randomExposedWord2 = exposedWords[Math.floor(Math.random() * exposedWords.length)];
      return {
        type: 'typing',
        word: _randomExposedWord2
      };
    } else {
      return {
        type: 'grammar-break',
        word: null
      };
    }
  }, [getExposedWords, getNewWords, wordListState.allWords, wordListManager]);

  // Single function to advance to next activity - SINGLE SOURCE OF TRUTH
  var advanceToNextActivity = React.useCallback(function () {
    var nextActivity = selectNextActivity();

    // Reset answer state for all components
    wordListManager.selectedAnswer = null;
    wordListManager.setShowAnswer(false);

    // Update journey state in one place
    setJourneyState({
      isInitialized: true,
      currentActivity: nextActivity.type,
      currentWord: nextActivity.word,
      showNewWordIndicator: nextActivity.type === 'new-word'
    });

    // If it's a new word, mark it as exposed
    if (nextActivity.type === 'new-word' && nextActivity.word) {
      markWordAsExposed(nextActivity.word);
    }

    // Generate multiple choice options if needed
    if ((nextActivity.type === 'multiple-choice' || nextActivity.type === 'listening') && nextActivity.word) {
      // Set current word for existing components
      var wordIndex = wordListState.allWords.findIndex(function (w) {
        return w.lithuanian === nextActivity.word.lithuanian && w.english === nextActivity.word.english;
      });
      if (wordIndex >= 0) {
        wordListManager.currentCard = wordIndex;
        wordListManager.notifyStateChange();
        wordListManager.generateMultipleChoiceOptions(studyMode, nextActivity.type);
      }
    }
  }, [selectNextActivity, wordListManager, wordListState.allWords, studyMode]);

  // Initialize first activity when ready
  React.useEffect(function () {
    if (journeyState.isInitialized && wordListState.allWords.length > 0 && !journeyState.currentActivity) {
      advanceToNextActivity();
    }
  }, [journeyState.isInitialized, wordListState.allWords.length, journeyState.currentActivity, advanceToNextActivity]);

  // Word stats update functions
  var markWordAsExposed = React.useCallback(function (word) {
    var wordKey = "".concat(word.lithuanian, "-").concat(word.english);
    var newStats = _objectSpread({}, journeyStats);
    if (!newStats[wordKey]) {
      newStats[wordKey] = {
        exposed: false,
        multipleChoice: {
          correct: 0,
          incorrect: 0
        },
        listening: {
          correct: 0,
          incorrect: 0
        },
        typing: {
          correct: 0,
          incorrect: 0
        },
        lastSeen: null
      };
    }
    newStats[wordKey].exposed = true;
    newStats[wordKey].lastSeen = Date.now();
    saveStats(newStats);
  }, [journeyStats, saveStats]);
  var updateWordStats = React.useCallback(function (word, mode, isCorrect) {
    var wordKey = "".concat(word.lithuanian, "-").concat(word.english);
    var newStats = _objectSpread({}, journeyStats);
    if (!newStats[wordKey]) {
      newStats[wordKey] = {
        exposed: true,
        multipleChoice: {
          correct: 0,
          incorrect: 0
        },
        listening: {
          correct: 0,
          incorrect: 0
        },
        typing: {
          correct: 0,
          incorrect: 0
        },
        lastSeen: null
      };
    }
    if (isCorrect) {
      newStats[wordKey][mode].correct++;
    } else {
      newStats[wordKey][mode].incorrect++;
    }
    newStats[wordKey].lastSeen = Date.now();
    saveStats(newStats);
  }, [journeyStats, saveStats]);

  // Event handlers that use the single advance function
  var handleActivityComplete = React.useCallback(function (word, mode, isCorrect) {
    var shouldAutoAdvance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    if (word && mode) {
      updateWordStats(word, mode, isCorrect);
    }
    if (shouldAutoAdvance && autoAdvance) {
      setTimeout(function () {
        advanceToNextActivity();
      }, defaultDelay * 1000);
    }
  }, [updateWordStats, autoAdvance, defaultDelay, advanceToNextActivity]);
  var handleJourneyMultipleChoice = React.useCallback(function (selectedOption) {
    if (!journeyState.currentWord) return;
    var currentWord = journeyState.currentWord;
    var correctAnswer;
    if (journeyState.currentActivity === 'listening') {
      correctAnswer = studyMode === 'lithuanian-to-english' ? currentWord.english : currentWord.lithuanian;
    } else {
      correctAnswer = studyMode === 'english-to-lithuanian' ? currentWord.lithuanian : currentWord.english;
    }
    var isCorrect = selectedOption === correctAnswer;
    var modeKey = journeyState.currentActivity === 'listening' ? 'listening' : 'multipleChoice';

    // Call the original handler for UI updates
    handleMultipleChoiceAnswer(selectedOption);

    // Handle completion through single function
    handleActivityComplete(currentWord, modeKey, isCorrect);
  }, [journeyState.currentWord, journeyState.currentActivity, studyMode, handleMultipleChoiceAnswer, handleActivityComplete]);
  var handleTypingComplete = React.useCallback(function (isCorrect) {
    handleActivityComplete(journeyState.currentWord, 'typing', isCorrect);
  }, [journeyState.currentWord, handleActivityComplete]);

  // Loading states
  if (!journeyState.isInitialized) {
    return /*#__PURE__*/React.createElement("div", {
      className: "w-card"
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-text-center w-mb-large"
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-question w-mb-large"
    }, "\uD83D\uDE80 Journey Mode"), /*#__PURE__*/React.createElement("div", null, "Initializing your learning journey...")));
  }
  if (!journeyState.currentActivity) {
    return /*#__PURE__*/React.createElement("div", {
      className: "w-card"
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-text-center w-mb-large"
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-question w-mb-large"
    }, "\uD83D\uDE80 Journey Mode"), /*#__PURE__*/React.createElement("div", null, "Loading your learning journey...")));
  }

  // Activity renderers
  if (journeyState.currentActivity === 'grammar-break') {
    return /*#__PURE__*/React.createElement("div", {
      className: "w-card"
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-text-center w-mb-large"
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-question w-mb-large"
    }, "\uD83D\uDCDA Grammar Break"), /*#__PURE__*/React.createElement("div", null, "Take a moment to review grammar concepts!"), /*#__PURE__*/React.createElement("div", {
      style: {
        margin: 'var(--spacing-large) 0'
      }
    }, /*#__PURE__*/React.createElement("p", null, "Consider reviewing:"), /*#__PURE__*/React.createElement("ul", {
      style: {
        textAlign: 'left',
        display: 'inline-block'
      }
    }, /*#__PURE__*/React.createElement("li", null, "Verb conjugations"), /*#__PURE__*/React.createElement("li", null, "Noun declensions"), /*#__PURE__*/React.createElement("li", null, "Sentence structure"))), /*#__PURE__*/React.createElement("button", {
      className: "w-button",
      onClick: advanceToNextActivity
    }, "Continue Journey")));
  }
  if (journeyState.currentActivity === 'new-word') {
    return /*#__PURE__*/React.createElement("div", null, journeyState.showNewWordIndicator && /*#__PURE__*/React.createElement("div", {
      className: "w-card",
      style: {
        background: 'linear-gradient(135deg, #4CAF50, #45a049)',
        color: 'white',
        marginBottom: 'var(--spacing-base)'
      }
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-text-center"
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: '1.5rem',
        fontWeight: 'bold'
      }
    }, "\u2728 New Word!"), /*#__PURE__*/React.createElement("div", null, "Learning something new on your journey"))), /*#__PURE__*/React.createElement(FlashCardMode, {
      currentWord: journeyState.currentWord,
      showAnswer: wordListState.showAnswer,
      setShowAnswer: function setShowAnswer(value) {
        return wordListManager.setShowAnswer(value);
      },
      studyMode: studyMode,
      audioEnabled: audioEnabled,
      playAudio: playAudio,
      handleHoverStart: handleHoverStart,
      handleHoverEnd: handleHoverEnd
    }), /*#__PURE__*/React.createElement("div", {
      className: "w-nav-controls"
    }, /*#__PURE__*/React.createElement("button", {
      className: "w-button",
      onClick: advanceToNextActivity
    }, "Next Activity \u2192")));
  }
  if (journeyState.currentActivity === 'multiple-choice') {
    return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
      className: "w-card",
      style: {
        background: 'linear-gradient(135deg, #2196F3, #1976D2)',
        color: 'white',
        marginBottom: 'var(--spacing-base)'
      }
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-text-center"
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: '1.2rem',
        fontWeight: 'bold'
      }
    }, "\uD83C\uDFAF Multiple Choice Challenge"))), /*#__PURE__*/React.createElement(MultipleChoiceMode, {
      wordListManager: wordListManager,
      wordListState: wordListState,
      studyMode: studyMode,
      audioEnabled: audioEnabled,
      playAudio: playAudio,
      handleHoverStart: handleHoverStart,
      handleHoverEnd: handleHoverEnd,
      handleMultipleChoiceAnswer: handleJourneyMultipleChoice
    }), !autoAdvance && /*#__PURE__*/React.createElement("div", {
      className: "w-nav-controls"
    }, /*#__PURE__*/React.createElement("button", {
      className: "w-button",
      onClick: advanceToNextActivity
    }, "Next Activity \u2192")));
  }
  if (journeyState.currentActivity === 'listening') {
    return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
      className: "w-card",
      style: {
        background: 'linear-gradient(135deg, #9C27B0, #7B1FA2)',
        color: 'white',
        marginBottom: 'var(--spacing-base)'
      }
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-text-center"
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: '1.2rem',
        fontWeight: 'bold'
      }
    }, "\uD83C\uDFA7 Listening Challenge"))), /*#__PURE__*/React.createElement(ListeningMode, {
      wordListManager: wordListManager,
      wordListState: wordListState,
      studyMode: studyMode,
      audioEnabled: audioEnabled,
      playAudio: playAudio,
      handleMultipleChoiceAnswer: handleJourneyMultipleChoice
    }), !autoAdvance && /*#__PURE__*/React.createElement("div", {
      className: "w-nav-controls"
    }, /*#__PURE__*/React.createElement("button", {
      className: "w-button",
      onClick: advanceToNextActivity
    }, "Next Activity \u2192")));
  }
  if (journeyState.currentActivity === 'typing') {
    return /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("div", {
      className: "w-card",
      style: {
        background: 'linear-gradient(135deg, #FF9800, #F57C00)',
        color: 'white',
        marginBottom: 'var(--spacing-base)'
      }
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-text-center"
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        fontSize: '1.2rem',
        fontWeight: 'bold'
      }
    }, "\u2328\uFE0F Typing Challenge"))), /*#__PURE__*/React.createElement(JourneyTypingMode, {
      journeyWord: journeyState.currentWord,
      studyMode: studyMode,
      audioEnabled: audioEnabled,
      playAudio: playAudio,
      onComplete: handleTypingComplete,
      autoAdvance: autoAdvance,
      defaultDelay: defaultDelay,
      onNext: advanceToNextActivity
    }));
  }
  return null;
};

// Custom typing mode component for Journey mode
var JourneyTypingMode = function JourneyTypingMode(_ref7) {
  var journeyWord = _ref7.journeyWord,
    studyMode = _ref7.studyMode,
    audioEnabled = _ref7.audioEnabled,
    playAudio = _ref7.playAudio,
    onComplete = _ref7.onComplete,
    autoAdvance = _ref7.autoAdvance,
    defaultDelay = _ref7.defaultDelay,
    onNext = _ref7.onNext;
  var _React$useState7 = React.useState(''),
    _React$useState8 = _slicedToArray(_React$useState7, 2),
    typedAnswer = _React$useState8[0],
    setTypedAnswer = _React$useState8[1];
  var _React$useState9 = React.useState(false),
    _React$useState0 = _slicedToArray(_React$useState9, 2),
    showAnswer = _React$useState0[0],
    setShowAnswer = _React$useState0[1];
  var _React$useState1 = React.useState(''),
    _React$useState10 = _slicedToArray(_React$useState1, 2),
    feedback = _React$useState10[0],
    setFeedback = _React$useState10[1];

  // Reset state when journeyWord changes
  React.useEffect(function () {
    setTypedAnswer('');
    setShowAnswer(false);
    setFeedback('');
  }, [journeyWord]);
  var handleSubmit = function handleSubmit(e) {
    e.preventDefault();
    if (!journeyWord || showAnswer) return;
    var correctAnswer = studyMode === 'english-to-lithuanian' ? journeyWord.lithuanian : journeyWord.english;
    var isCorrect = typedAnswer.trim().toLowerCase() === correctAnswer.toLowerCase();
    if (isCorrect) {
      setFeedback('✅ Correct!');
    } else {
      setFeedback("\u274C Incorrect. The answer is: ".concat(correctAnswer));
    }
    setShowAnswer(true);
    onComplete(isCorrect);
  };
  var question = studyMode === 'english-to-lithuanian' ? journeyWord.english : journeyWord.lithuanian;
  return /*#__PURE__*/React.createElement("div", {
    className: "w-card"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-badge"
  }, journeyWord.corpus, " \u2192 ", journeyWord.group), /*#__PURE__*/React.createElement("div", {
    className: "w-question w-mb-large"
  }, /*#__PURE__*/React.createElement("div", null, question), audioEnabled && studyMode === 'lithuanian-to-english' && /*#__PURE__*/React.createElement("div", {
    style: {
      marginTop: 'var(--spacing-base)'
    }
  }, /*#__PURE__*/React.createElement(AudioButton, {
    word: question,
    audioEnabled: audioEnabled,
    playAudio: playAudio
  }))), /*#__PURE__*/React.createElement("form", {
    onSubmit: handleSubmit
  }, /*#__PURE__*/React.createElement("input", {
    type: "text",
    value: typedAnswer,
    onChange: function onChange(e) {
      return setTypedAnswer(e.target.value);
    },
    placeholder: "Type the ".concat(studyMode === 'english-to-lithuanian' ? 'Lithuanian' : 'English', " translation"),
    className: "w-text-input",
    disabled: showAnswer,
    autoFocus: true
  }), /*#__PURE__*/React.createElement("button", {
    type: "submit",
    className: "w-button w-button-primary w-mt-base",
    disabled: showAnswer || !typedAnswer.trim()
  }, "Check Answer")), feedback && /*#__PURE__*/React.createElement("div", {
    className: "w-feedback ".concat(feedback.includes('✅') ? 'w-success' : 'w-error')
  }, feedback), showAnswer && /*#__PURE__*/React.createElement("div", {
    className: "trakaido-answer-text"
  }, /*#__PURE__*/React.createElement("span", null, studyMode === 'english-to-lithuanian' ? journeyWord.lithuanian : journeyWord.english), audioEnabled && /*#__PURE__*/React.createElement(AudioButton, {
    word: studyMode === 'english-to-lithuanian' ? journeyWord.lithuanian : journeyWord.english,
    audioEnabled: audioEnabled,
    playAudio: playAudio
  })), showAnswer && !autoAdvance && /*#__PURE__*/React.createElement("div", {
    className: "w-nav-controls"
  }, /*#__PURE__*/React.createElement("button", {
    className: "w-button",
    onClick: onNext
  }, "Next Activity \u2192")));
};
window.JourneyMode = JourneyMode;
;



"use strict";

function _regenerator() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ var e, t, r = "function" == typeof Symbol ? Symbol : {}, n = r.iterator || "@@iterator", o = r.toStringTag || "@@toStringTag"; function i(r, n, o, i) { var c = n && n.prototype instanceof Generator ? n : Generator, u = Object.create(c.prototype); return _regeneratorDefine2(u, "_invoke", function (r, n, o) { var i, c, u, f = 0, p = o || [], y = !1, G = { p: 0, n: 0, v: e, a: d, f: d.bind(e, 4), d: function d(t, r) { return i = t, c = 0, u = e, G.n = r, a; } }; function d(r, n) { for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) { var o, i = p[t], d = G.p, l = i[2]; r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0)); } if (o || r > 1) return a; throw y = !0, n; } return function (o, p, l) { if (f > 1) throw TypeError("Generator is already running"); for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) { i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u); try { if (f = 2, i) { if (c || (o = "next"), t = i[o]) { if (!(t = t.call(i, u))) throw TypeError("iterator result is not an object"); if (!t.done) return t; u = t.value, c < 2 && (c = 0); } else 1 === c && (t = i["return"]) && t.call(i), c < 2 && (u = TypeError("The iterator does not provide a '" + o + "' method"), c = 1); i = e; } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break; } catch (t) { i = e, c = 1, u = t; } finally { f = 1; } } return { value: t, done: y }; }; }(r, o, i), !0), u; } var a = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} t = Object.getPrototypeOf; var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () { return this; }), t), u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c); function f(e) { return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, "GeneratorFunction")), e.prototype = Object.create(u), e; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, "constructor", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = "GeneratorFunction", _regeneratorDefine2(GeneratorFunctionPrototype, o, "GeneratorFunction"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, "Generator"), _regeneratorDefine2(u, n, function () { return this; }), _regeneratorDefine2(u, "toString", function () { return "[object Generator]"; }), (_regenerator = function _regenerator() { return { w: i, m: f }; })(); }
function _regeneratorDefine2(e, r, n, t) { var i = Object.defineProperty; try { i({}, "", {}); } catch (e) { i = 0; } _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) { if (r) i ? i(e, r, { value: n, enumerable: !t, configurable: !t, writable: !t }) : e[r] = n;else { var o = function o(r, n) { _regeneratorDefine2(e, r, function (e) { return this._invoke(r, n, e); }); }; o("next", 0), o("throw", 1), o("return", 2); } }, _regeneratorDefine2(e, r, n, t); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
// import React, { useState, useEffect } from 'react';
// import { useGlobalSettings } from './useGlobalSettings';  // This is the correct syntax for now; it is awkward and possibly should be updated.
// import { useFullscreen } from './useFullscreen';
// import VocabularyList from './VocabularyList';
// import TypingMode from './TypingMode';
// import StatsDisplay from './StatsDisplay';
// import FlashCardMode from './FlashCardMode';
// import ListeningMode from './ListeningMode';
// import MultipleChoiceMode from './MultipleChoiceMode';
// import StudyMaterialsModal from './StudyMaterialsModal';
// import StudyModeSelector from './StudyModeSelector';
// import ConjugationsMode from './ConjugationsMode';
// import DeclensionsMode from './DeclensionsMode';
// import WordListManager from './WordListManager';
// import SplashScreen from './SplashScreen';
// import WelcomeScreen from './WelcomeScreen';
// import JourneyMode from './JourneyMode';
// import safeStorage from './safeStorage';

// Use the namespaced lithuanianApi from window
// These are provided by the script tag in widget.html: /js/lithuanianApi.js
var _window$lithuanianApi = window.lithuanianApi,
  fetchCorpora = _window$lithuanianApi.fetchCorpora,
  fetchCorpusStructure = _window$lithuanianApi.fetchCorpusStructure,
  fetchAvailableVoices = _window$lithuanianApi.fetchAvailableVoices,
  fetchVerbCorpuses = _window$lithuanianApi.fetchVerbCorpuses,
  fetchConjugations = _window$lithuanianApi.fetchConjugations,
  fetchDeclensions = _window$lithuanianApi.fetchDeclensions,
  AudioManager = _window$lithuanianApi.AudioManager;

// The CSS classes available are primarily in widget_tools.css .

var FlashCardApp = function FlashCardApp() {
  // Global settings integration
  var _useGlobalSettings = useGlobalSettings({
      usedSettings: ['audioEnabled', 'soundVolume', 'autoAdvance', 'defaultDelay', 'difficulty']
    }),
    settings = _useGlobalSettings.settings,
    SettingsModal = _useGlobalSettings.SettingsModal,
    SettingsToggle = _useGlobalSettings.SettingsToggle;

  // Fullscreen functionality
  var _useFullscreen = useFullscreen(),
    isFullscreen = _useFullscreen.isFullscreen,
    toggleFullscreen = _useFullscreen.toggleFullscreen,
    containerRef = _useFullscreen.containerRef;
  var _useState = useState({}),
    _useState2 = _slicedToArray(_useState, 2),
    corporaData = _useState2[0],
    setCorporaData = _useState2[1]; // Cache for corpus structures
  var _useState3 = useState([]),
    _useState4 = _slicedToArray(_useState3, 2),
    availableCorpora = _useState4[0],
    setAvailableCorpora = _useState4[1];
  // Initialize selectedGroups from localStorage if available
  var _useState5 = useState(function () {
      var _safeStorage;
      var savedGroups = (_safeStorage = safeStorage) === null || _safeStorage === void 0 ? void 0 : _safeStorage.getItem('flashcard-selected-groups');
      try {
        return savedGroups ? JSON.parse(savedGroups) : {};
      } catch (error) {
        console.error('Error parsing saved corpus groups:', error);
        return {};
      }
    }),
    _useState6 = _slicedToArray(_useState5, 2),
    selectedGroups = _useState6[0],
    setSelectedGroups = _useState6[1]; // {corpus: [group1, group2]}

  // Initialize local settings from localStorage where available
  var _useState7 = useState(function () {
      var _safeStorage2;
      return ((_safeStorage2 = safeStorage) === null || _safeStorage2 === void 0 ? void 0 : _safeStorage2.getItem('flashcard-study-mode')) || 'english-to-lithuanian';
    }),
    _useState8 = _slicedToArray(_useState7, 2),
    studyMode = _useState8[0],
    setStudyMode = _useState8[1];
  var _useState9 = useState(function () {
      var _safeStorage3;
      return ((_safeStorage3 = safeStorage) === null || _safeStorage3 === void 0 ? void 0 : _safeStorage3.getItem('flashcard-quiz-mode')) || 'flashcard';
    }),
    _useState0 = _slicedToArray(_useState9, 2),
    quizMode = _useState0[0],
    setQuizMode = _useState0[1];
  var _useState1 = useState('conjugations'),
    _useState10 = _slicedToArray(_useState1, 2),
    grammarMode = _useState10[0],
    setGrammarMode = _useState10[1];

  // WordListManager state
  var _useState11 = useState({
      allWords: [],
      currentCard: 0,
      showAnswer: false,
      selectedAnswer: null,
      typedAnswer: '',
      typingFeedback: '',
      multipleChoiceOptions: [],
      stats: {
        correct: 0,
        incorrect: 0,
        total: 0
      },
      autoAdvanceTimer: null
    }),
    _useState12 = _slicedToArray(_useState11, 2),
    wordListState = _useState12[0],
    setWordListState = _useState12[1];
  var _useState13 = useState(function () {
      return new AudioManager();
    }),
    _useState14 = _slicedToArray(_useState13, 1),
    audioManager = _useState14[0];
  var _useState15 = useState(function () {
      return new WordListManager(safeStorage, settings);
    }),
    _useState16 = _slicedToArray(_useState15, 1),
    wordListManager = _useState16[0];
  var _useState17 = useState(null),
    _useState18 = _slicedToArray(_useState17, 2),
    hoverTimeout = _useState18[0],
    setHoverTimeout = _useState18[1];
  var _useState19 = useState([]),
    _useState20 = _slicedToArray(_useState19, 2),
    availableVoices = _useState20[0],
    setAvailableVoices = _useState20[1];
  var _useState21 = useState(function () {
      var _safeStorage4;
      return ((_safeStorage4 = safeStorage) === null || _safeStorage4 === void 0 ? void 0 : _safeStorage4.getItem('flashcard-selected-voice')) || null;
    }),
    _useState22 = _slicedToArray(_useState21, 2),
    selectedVoice = _useState22[0],
    setSelectedVoice = _useState22[1];
  var _useState23 = useState(true),
    _useState24 = _slicedToArray(_useState23, 2),
    showSplash = _useState24[0],
    setShowSplash = _useState24[1];
  var _useState25 = useState(function () {
      var _safeStorage5;
      return !((_safeStorage5 = safeStorage) !== null && _safeStorage5 !== void 0 && _safeStorage5.getItem('trakaido-has-seen-intro'));
    }),
    _useState26 = _slicedToArray(_useState25, 2),
    showWelcome = _useState26[0],
    setShowWelcome = _useState26[1];
  var _useState27 = useState(true),
    _useState28 = _slicedToArray(_useState27, 2),
    loading = _useState28[0],
    setLoading = _useState28[1];
  var _useState29 = useState(null),
    _useState30 = _slicedToArray(_useState29, 2),
    error = _useState30[0],
    setError = _useState30[1];
  var _useState31 = useState(false),
    _useState32 = _slicedToArray(_useState31, 2),
    showStudyMaterialsModal = _useState32[0],
    setShowStudyMaterialsModal = _useState32[1];
  var _useState33 = useState(false),
    _useState34 = _slicedToArray(_useState33, 2),
    loadingWords = _useState34[0],
    setLoadingWords = _useState34[1];
  var _useState35 = useState({}),
    _useState36 = _slicedToArray(_useState35, 2),
    conjugations = _useState36[0],
    setConjugations = _useState36[1];
  var _useState37 = useState([]),
    _useState38 = _slicedToArray(_useState37, 2),
    availableVerbs = _useState38[0],
    setAvailableVerbs = _useState38[1];
  var _useState39 = useState(null),
    _useState40 = _slicedToArray(_useState39, 2),
    selectedVerb = _useState40[0],
    setSelectedVerb = _useState40[1];
  var _useState41 = useState(false),
    _useState42 = _slicedToArray(_useState41, 2),
    loadingConjugations = _useState42[0],
    setLoadingConjugations = _useState42[1];
  var _useState43 = useState([]),
    _useState44 = _slicedToArray(_useState43, 2),
    availableVerbCorpuses = _useState44[0],
    setAvailableVerbCorpuses = _useState44[1];
  var _useState45 = useState('verbs_present'),
    _useState46 = _slicedToArray(_useState45, 2),
    selectedVerbCorpus = _useState46[0],
    setSelectedVerbCorpus = _useState46[1];
  var _useState47 = useState({}),
    _useState48 = _slicedToArray(_useState47, 2),
    declensions = _useState48[0],
    setDeclensions = _useState48[1];
  var _useState49 = useState([]),
    _useState50 = _slicedToArray(_useState49, 2),
    availableNouns = _useState50[0],
    setAvailableNouns = _useState50[1];
  var _useState51 = useState(null),
    _useState52 = _slicedToArray(_useState51, 2),
    selectedNoun = _useState52[0],
    setSelectedNoun = _useState52[1];
  var _useState53 = useState(null),
    _useState54 = _slicedToArray(_useState53, 2),
    selectedVocabGroup = _useState54[0],
    setSelectedVocabGroup = _useState54[1];
  var _useState55 = useState([]),
    _useState56 = _slicedToArray(_useState55, 2),
    vocabGroupOptions = _useState56[0],
    setVocabGroupOptions = _useState56[1];
  var _useState57 = useState([]),
    _useState58 = _slicedToArray(_useState57, 2),
    vocabListWords = _useState58[0],
    setVocabListWords = _useState58[1];

  // Use global settings for audio and auto-advance
  var audioEnabled = settings.audioEnabled;
  var autoAdvance = settings.autoAdvance;
  var defaultDelay = settings.defaultDelay;

  // Setup WordListManager callback
  useEffect(function () {
    wordListManager.setStateChangeCallback(setWordListState);
    wordListManager.settings = settings; // Update settings reference
  }, [wordListManager, settings]);

  // Handle splash screen timing
  useEffect(function () {
    var splashTimer = setTimeout(function () {
      setShowSplash(false);
    }, 2000); // Show splash for 2 seconds

    return function () {
      return clearTimeout(splashTimer);
    };
  }, []);

  // Load initial data
  useEffect(function () {
    var loadInitialData = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee() {
        var _safeStorage6, _yield$Promise$all, _yield$Promise$all2, corpora, voices, verbCorpuses, conjugationData, declensionData, corporaStructures, hasSeenIntro, useDefaults, defaultSelectedGroups, _iterator, _step, corpus, structure, groups, _t, _t2, _t3;
        return _regenerator().w(function (_context) {
          while (1) switch (_context.n) {
            case 0:
              if (!showSplash) {
                _context.n = 1;
                break;
              }
              return _context.a(2);
            case 1:
              setLoading(true);
              setError(null);
              _context.p = 2;
              _context.n = 3;
              return Promise.all([fetchCorpora(), fetchAvailableVoices(), fetchVerbCorpuses(), fetchConjugations(), fetchDeclensions()]);
            case 3:
              _yield$Promise$all = _context.v;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 5);
              corpora = _yield$Promise$all2[0];
              voices = _yield$Promise$all2[1];
              verbCorpuses = _yield$Promise$all2[2];
              conjugationData = _yield$Promise$all2[3];
              declensionData = _yield$Promise$all2[4];
              setAvailableCorpora(corpora);
              setAvailableVoices(voices);
              setAvailableVerbCorpuses(verbCorpuses);
              setConjugations(conjugationData.conjugations);
              setAvailableVerbs(conjugationData.verbs);
              setDeclensions(declensionData.declensions);
              setAvailableNouns(declensionData.available_nouns);
              if (voices.length > 0 && !selectedVoice) {
                setSelectedVoice('random');
              }
              corporaStructures = {}; // Only set default groups if we don't have any saved in localStorage AND user has seen intro
              hasSeenIntro = (_safeStorage6 = safeStorage) === null || _safeStorage6 === void 0 ? void 0 : _safeStorage6.getItem('trakaido-has-seen-intro');
              useDefaults = Object.keys(selectedGroups).length === 0 && hasSeenIntro;
              defaultSelectedGroups = useDefaults ? {} : null;
              _iterator = _createForOfIteratorHelper(corpora);
              _context.p = 4;
              _iterator.s();
            case 5:
              if ((_step = _iterator.n()).done) {
                _context.n = 10;
                break;
              }
              corpus = _step.value;
              _context.p = 6;
              _context.n = 7;
              return fetchCorpusStructure(corpus);
            case 7:
              structure = _context.v;
              corporaStructures[corpus] = structure;

              // If we're using defaults, set all groups as selected
              if (useDefaults) {
                groups = Object.keys(structure.groups);
                defaultSelectedGroups[corpus] = groups;
              }
              _context.n = 9;
              break;
            case 8:
              _context.p = 8;
              _t = _context.v;
              console.warn("Failed to load structure for corpus: ".concat(corpus), _t);
            case 9:
              _context.n = 5;
              break;
            case 10:
              _context.n = 12;
              break;
            case 11:
              _context.p = 11;
              _t2 = _context.v;
              _iterator.e(_t2);
            case 12:
              _context.p = 12;
              _iterator.f();
              return _context.f(12);
            case 13:
              setCorporaData(corporaStructures);

              // Only update selectedGroups if we're using defaults
              if (useDefaults) {
                setSelectedGroups(defaultSelectedGroups);
              }
              _context.n = 15;
              break;
            case 14:
              _context.p = 14;
              _t3 = _context.v;
              console.error('Failed to load initial data:', _t3);
              setError('Failed to load vocabulary data. Please try refreshing the page.');
            case 15:
              _context.p = 15;
              setLoading(false);
              return _context.f(15);
            case 16:
              return _context.a(2);
          }
        }, _callee, null, [[6, 8], [4, 11, 12, 13], [2, 14, 15, 16]]);
      }));
      return function loadInitialData() {
        return _ref.apply(this, arguments);
      };
    }();
    loadInitialData();
  }, [showSplash]);

  // Save settings to localStorage whenever they change
  useEffect(function () {
    safeStorage.setItem('flashcard-selected-groups', JSON.stringify(selectedGroups));
  }, [selectedGroups]);
  useEffect(function () {
    safeStorage.setItem('flashcard-study-mode', studyMode);
  }, [studyMode]);
  useEffect(function () {
    safeStorage.setItem('flashcard-quiz-mode', quizMode);
  }, [quizMode]);
  useEffect(function () {
    if (selectedVoice) {
      safeStorage.setItem('flashcard-selected-voice', selectedVoice);
    }
  }, [selectedVoice]);

  // Generate words list when selected groups change
  useEffect(function () {
    if (!loading) {
      wordListManager.generateWordsList(selectedGroups, corporaData);
    }
  }, [selectedGroups, loading, corporaData, wordListManager]);

  // Generate multiple choice options when card changes or mode changes
  useEffect(function () {
    if ((quizMode === 'multiple-choice' || quizMode === 'listening') && wordListState.allWords.length > 0) {
      wordListManager.generateMultipleChoiceOptions(studyMode, quizMode);
    }
  }, [wordListState.currentCard, quizMode, wordListState.allWords, studyMode, settings.difficulty, wordListManager]);

  // Pre-load audio for multiple choice options when audio is enabled
  useEffect(function () {
    if (audioEnabled && (quizMode === 'multiple-choice' || quizMode === 'listening') && wordListState.multipleChoiceOptions.length > 0) {
      preloadMultipleChoiceAudio();
    }
  }, [audioEnabled, quizMode, studyMode, wordListState.multipleChoiceOptions, selectedVoice]);

  // Auto-play audio in listening mode when card changes
  useEffect(function () {
    if (quizMode === 'listening' && audioEnabled && wordListState.allWords.length > 0 && wordListState.allWords[wordListState.currentCard]) {
      // Small delay to ensure the UI has updated
      var timer = setTimeout(function () {
        playAudio(wordListState.allWords[wordListState.currentCard].lithuanian);
      }, 300);
      return function () {
        return clearTimeout(timer);
      };
    }
  }, [wordListState.currentCard, quizMode, audioEnabled, wordListState.allWords]);

  // Reload conjugations when verb corpus changes
  useEffect(function () {
    var loadConjugationsForCorpus = /*#__PURE__*/function () {
      var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2() {
        var conjugationData, _t4;
        return _regenerator().w(function (_context2) {
          while (1) switch (_context2.n) {
            case 0:
              if (!(selectedVerbCorpus && !loading)) {
                _context2.n = 5;
                break;
              }
              setLoadingConjugations(true);
              _context2.p = 1;
              _context2.n = 2;
              return fetchConjugations(selectedVerbCorpus);
            case 2:
              conjugationData = _context2.v;
              setConjugations(conjugationData.conjugations);
              setAvailableVerbs(conjugationData.verbs);
              // Only reset selected verb if it doesn't exist in the new corpus
              if (selectedVerb && !conjugationData.verbs.includes(selectedVerb)) {
                setSelectedVerb(null);
              }
              _context2.n = 4;
              break;
            case 3:
              _context2.p = 3;
              _t4 = _context2.v;
              console.error('Failed to load conjugations for corpus:', selectedVerbCorpus, _t4);
            case 4:
              _context2.p = 4;
              setLoadingConjugations(false);
              return _context2.f(4);
            case 5:
              return _context2.a(2);
          }
        }, _callee2, null, [[1, 3, 4, 5]]);
      }));
      return function loadConjugationsForCorpus() {
        return _ref2.apply(this, arguments);
      };
    }();
    loadConjugationsForCorpus();
  }, [selectedVerbCorpus, loading]);
  var preloadMultipleChoiceAudio = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee3() {
      var _iterator2, _step2, voice, _t5;
      return _regenerator().w(function (_context3) {
        while (1) switch (_context3.n) {
          case 0:
            if (selectedVoice) {
              _context3.n = 1;
              break;
            }
            return _context3.a(2);
          case 1:
            if (!(selectedVoice === 'random')) {
              _context3.n = 9;
              break;
            }
            // When random is selected, preload for all available voices
            _iterator2 = _createForOfIteratorHelper(availableVoices);
            _context3.p = 2;
            _iterator2.s();
          case 3:
            if ((_step2 = _iterator2.n()).done) {
              _context3.n = 5;
              break;
            }
            voice = _step2.value;
            _context3.n = 4;
            return audioManager.preloadMultipleAudio(wordListState.multipleChoiceOptions, voice);
          case 4:
            _context3.n = 3;
            break;
          case 5:
            _context3.n = 7;
            break;
          case 6:
            _context3.p = 6;
            _t5 = _context3.v;
            _iterator2.e(_t5);
          case 7:
            _context3.p = 7;
            _iterator2.f();
            return _context3.f(7);
          case 8:
            _context3.n = 10;
            break;
          case 9:
            _context3.n = 10;
            return audioManager.preloadMultipleAudio(wordListState.multipleChoiceOptions, selectedVoice);
          case 10:
            return _context3.a(2);
        }
      }, _callee3, null, [[2, 6, 7, 8]]);
    }));
    return function preloadMultipleChoiceAudio() {
      return _ref3.apply(this, arguments);
    };
  }();

  // Generate all available groups from all corpuses
  useEffect(function () {
    if (Object.keys(corporaData).length === 0) return;
    var options = [];
    // Iterate through all corpuses and their groups
    Object.entries(corporaData).forEach(function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2),
        corpus = _ref5[0],
        data = _ref5[1];
      Object.keys(data.groups || {}).forEach(function (group) {
        var _data$groups$group;
        options.push({
          corpus: corpus,
          group: group,
          displayName: "".concat(corpus, " - ").concat(group),
          wordCount: ((_data$groups$group = data.groups[group]) === null || _data$groups$group === void 0 ? void 0 : _data$groups$group.length) || 0
        });
      });
    });

    // Sort alphabetically by display name
    options.sort(function (a, b) {
      return a.displayName.localeCompare(b.displayName);
    });
    setVocabGroupOptions(options);
  }, [corporaData]);
  var handleWelcomeComplete = function handleWelcomeComplete(skillLevel) {
    // Mark that user has seen the intro
    safeStorage.setItem('trakaido-has-seen-intro', 'true');

    // Set initial corpus selection based on skill level
    var initialSelectedGroups = {};
    if (skillLevel === 'beginner') {
      // For beginners, only enable nouns_one corpus
      if (corporaData['nouns_one']) {
        var _corporaData$nouns_on;
        initialSelectedGroups['nouns_one'] = Object.keys(((_corporaData$nouns_on = corporaData['nouns_one']) === null || _corporaData$nouns_on === void 0 ? void 0 : _corporaData$nouns_on.groups) || {});
      }
    } else if (skillLevel === 'intermediate') {
      // For intermediate, enable a moderate selection
      ['nouns_one', 'nouns_two', 'verbs_present'].forEach(function (corpus) {
        if (corporaData[corpus]) {
          var _corporaData$corpus;
          initialSelectedGroups[corpus] = Object.keys(((_corporaData$corpus = corporaData[corpus]) === null || _corporaData$corpus === void 0 ? void 0 : _corporaData$corpus.groups) || {});
        }
      });
    } else {
      // For experts, enable all groups (same as current default)
      Object.keys(corporaData).forEach(function (corpus) {
        var _corporaData$corpus2;
        initialSelectedGroups[corpus] = Object.keys(((_corporaData$corpus2 = corporaData[corpus]) === null || _corporaData$corpus2 === void 0 ? void 0 : _corporaData$corpus2.groups) || {});
      });
    }
    setSelectedGroups(initialSelectedGroups);
    setShowWelcome(false);
  };
  var resetAllSettings = function resetAllSettings() {
    // Clear localStorage items
    safeStorage.removeItem('flashcard-selected-groups');
    safeStorage.removeItem('flashcard-study-mode');
    safeStorage.removeItem('flashcard-quiz-mode');
    safeStorage.removeItem('flashcard-selected-voice');
    safeStorage.removeItem('trakaido-has-seen-intro');

    // Reset state to defaults
    setStudyMode('english-to-lithuanian');
    setQuizMode('flashcard');
    setSelectedVoice('random');
    setShowWelcome(true);

    // For corpus groups, we need to reset to all groups
    var defaultSelectedGroups = {};
    Object.keys(corporaData).forEach(function (corpus) {
      var _corporaData$corpus3;
      defaultSelectedGroups[corpus] = Object.keys(((_corporaData$corpus3 = corporaData[corpus]) === null || _corporaData$corpus3 === void 0 ? void 0 : _corporaData$corpus3.groups) || {});
    });
    setSelectedGroups(defaultSelectedGroups);
  };
  var nextCard = function nextCard() {
    return wordListManager.nextCard();
  };
  var prevCard = function prevCard() {
    return wordListManager.prevCard();
  };
  var resetCards = function resetCards() {
    return wordListManager.resetCards();
  };
  var handleMultipleChoiceAnswer = function handleMultipleChoiceAnswer(selectedOption) {
    return wordListManager.handleMultipleChoiceAnswer(selectedOption, studyMode, quizMode, autoAdvance, defaultDelay);
  };

  // Helper function to get a random voice from available voices
  var getRandomVoice = function getRandomVoice() {
    if (availableVoices.length === 0) return null;
    var randomIndex = Math.floor(Math.random() * availableVoices.length);
    return availableVoices[randomIndex];
  };

  // Helper function to get the actual voice to use (handles random selection)
  var getVoiceToUse = function getVoiceToUse() {
    if (selectedVoice === 'random') {
      return getRandomVoice();
    }
    return selectedVoice;
  };
  var playAudio = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee4(word) {
      var onlyCached,
        voiceToUse,
        _args4 = arguments;
      return _regenerator().w(function (_context4) {
        while (1) switch (_context4.n) {
          case 0:
            onlyCached = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : false;
            voiceToUse = getVoiceToUse();
            audioManager.playAudio(word, voiceToUse, audioEnabled, onlyCached);
          case 1:
            return _context4.a(2);
        }
      }, _callee4);
    }));
    return function playAudio(_x) {
      return _ref6.apply(this, arguments);
    };
  }();
  var handleHoverStart = function handleHoverStart(word) {
    if (!audioEnabled || !selectedVoice) return;
    var timeout = setTimeout(function () {
      playAudio(word, true); // Only play if cached
    }, 900);
    setHoverTimeout(timeout);
  };
  var handleHoverEnd = function handleHoverEnd() {
    if (hoverTimeout) {
      clearTimeout(hoverTimeout);
      setHoverTimeout(null);
    }
  };
  var currentWord = wordListManager.getCurrentWord();
  var totalSelectedWords = wordListManager.getTotalWords();

  // Splash screen
  if (showSplash) {
    return /*#__PURE__*/React.createElement(SplashScreen, null);
  }

  // Welcome screen for new users
  if (showWelcome && !loading && !error) {
    return /*#__PURE__*/React.createElement(WelcomeScreen, {
      onComplete: handleWelcomeComplete
    });
  }

  // Loading state
  if (loading) {
    return /*#__PURE__*/React.createElement("div", {
      className: "w-container"
    }, /*#__PURE__*/React.createElement("h1", null, "\uD83C\uDDF1\uD83C\uDDF9 Lithuanian Vocabulary Flash Cards"), /*#__PURE__*/React.createElement("div", {
      className: "w-card"
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-text-center w-mb-large"
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-question w-mb-large"
    }, "Loading vocabulary data..."), /*#__PURE__*/React.createElement("div", {
      className: "w-stat-label"
    }, "This may take a moment"))));
  }
  if (error) {
    return /*#__PURE__*/React.createElement("div", {
      className: "w-container"
    }, /*#__PURE__*/React.createElement("h1", null, "\uD83C\uDDF1\uD83C\uDDF9 Lithuanian Vocabulary Flash Cards"), /*#__PURE__*/React.createElement("div", {
      className: "w-card"
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-text-center w-mb-large"
    }, /*#__PURE__*/React.createElement("div", {
      className: "w-feedback w-error"
    }, "\u26A0\uFE0F Error"), /*#__PURE__*/React.createElement("div", {
      className: "w-mb-large"
    }, error), /*#__PURE__*/React.createElement("button", {
      className: "w-button",
      onClick: function onClick() {
        return window.location.reload();
      }
    }, "\uD83D\uDD04 Retry"))));
  }

  // Show "no groups selected" message but keep the Study Materials section visible
  // Don't show this message in conjugations/declensions/journey mode since they don't need word lists or handle them differently
  var showNoGroupsMessage = !currentWord && totalSelectedWords === 0 && quizMode !== 'conjugations' && quizMode !== 'declensions' && quizMode !== 'journey';
  return /*#__PURE__*/React.createElement("div", {
    ref: containerRef,
    className: "w-container ".concat(isFullscreen ? 'w-fullscreen' : '')
  }, !isFullscreen && /*#__PURE__*/React.createElement("h1", null, "\uD83C\uDDF1\uD83C\uDDF9 Trakaido!"), /*#__PURE__*/React.createElement(StudyModeSelector, {
    quizMode: quizMode,
    setQuizMode: setQuizMode,
    grammarMode: grammarMode,
    setGrammarMode: setGrammarMode,
    studyMode: studyMode,
    setStudyMode: setStudyMode,
    safeStorage: safeStorage,
    SettingsToggle: SettingsToggle,
    audioEnabled: audioEnabled,
    availableVoices: availableVoices,
    selectedVoice: selectedVoice,
    setSelectedVoice: setSelectedVoice,
    isFullscreen: isFullscreen,
    toggleFullscreen: toggleFullscreen,
    totalSelectedWords: totalSelectedWords,
    onOpenStudyMaterials: function onOpenStudyMaterials() {
      return setShowStudyMaterialsModal(true);
    }
  }), !showNoGroupsMessage && /*#__PURE__*/React.createElement("div", {
    className: "w-progress"
  }, "Card ", wordListState.currentCard + 1, " of ", wordListState.allWords.length), showNoGroupsMessage ? /*#__PURE__*/React.createElement("div", {
    className: "w-card"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-text-center w-mb-large"
  }, /*#__PURE__*/React.createElement("div", {
    className: "w-question w-mb-large"
  }, "\uD83D\uDCED No Words Available"), /*#__PURE__*/React.createElement("div", null, "No vocabulary words found for the selected groups. Please try selecting different groups."))) : quizMode === 'conjugations' ? /*#__PURE__*/React.createElement(ConjugationsMode, {
    selectedVerbCorpus: selectedVerbCorpus,
    setSelectedVerbCorpus: setSelectedVerbCorpus,
    availableVerbCorpuses: availableVerbCorpuses,
    loadingConjugations: loadingConjugations,
    selectedVerb: selectedVerb,
    setSelectedVerb: setSelectedVerb,
    availableVerbs: availableVerbs,
    conjugations: conjugations,
    audioEnabled: audioEnabled,
    playAudio: playAudio,
    handleHoverStart: handleHoverStart,
    handleHoverEnd: handleHoverEnd
  }) : quizMode === 'declensions' ? /*#__PURE__*/React.createElement(DeclensionsMode, {
    selectedNoun: selectedNoun,
    setSelectedNoun: setSelectedNoun,
    availableNouns: availableNouns,
    declensions: declensions,
    audioEnabled: audioEnabled,
    playAudio: playAudio,
    handleHoverStart: handleHoverStart,
    handleHoverEnd: handleHoverEnd
  }) : quizMode === 'vocabulary-list' ? /*#__PURE__*/React.createElement(VocabularyList, {
    selectedVocabGroup: selectedVocabGroup,
    setSelectedVocabGroup: setSelectedVocabGroup,
    vocabGroupOptions: vocabGroupOptions,
    vocabListWords: vocabListWords,
    setVocabListWords: setVocabListWords,
    corporaData: corporaData,
    audioEnabled: audioEnabled,
    playAudio: playAudio
  }) : quizMode === 'journey' ? /*#__PURE__*/React.createElement(JourneyMode, {
    wordListManager: wordListManager,
    wordListState: wordListState,
    studyMode: studyMode,
    audioEnabled: audioEnabled,
    playAudio: playAudio,
    handleHoverStart: handleHoverStart,
    handleHoverEnd: handleHoverEnd,
    handleMultipleChoiceAnswer: handleMultipleChoiceAnswer,
    nextCard: nextCard,
    autoAdvance: autoAdvance,
    defaultDelay: defaultDelay,
    safeStorage: safeStorage
  }) : quizMode === 'flashcard' ? /*#__PURE__*/React.createElement(FlashCardMode, {
    currentWord: currentWord,
    showAnswer: wordListState.showAnswer,
    setShowAnswer: function setShowAnswer(value) {
      return wordListManager.setShowAnswer(value);
    },
    studyMode: studyMode,
    audioEnabled: audioEnabled,
    playAudio: playAudio,
    handleHoverStart: handleHoverStart,
    handleHoverEnd: handleHoverEnd
  }) : quizMode === 'typing' ? /*#__PURE__*/React.createElement(TypingMode, {
    wordListManager: wordListManager,
    wordListState: wordListState,
    studyMode: studyMode,
    nextCard: nextCard,
    audioEnabled: audioEnabled,
    playAudio: playAudio,
    autoAdvance: autoAdvance,
    defaultDelay: defaultDelay
  }) : quizMode === 'listening' && currentWord ? /*#__PURE__*/React.createElement(ListeningMode, {
    wordListManager: wordListManager,
    wordListState: wordListState,
    studyMode: studyMode,
    audioEnabled: audioEnabled,
    playAudio: playAudio,
    handleMultipleChoiceAnswer: handleMultipleChoiceAnswer
  }) : quizMode === 'multiple-choice' && currentWord ? /*#__PURE__*/React.createElement(MultipleChoiceMode, {
    wordListManager: wordListManager,
    wordListState: wordListState,
    studyMode: studyMode,
    audioEnabled: audioEnabled,
    playAudio: playAudio,
    handleHoverStart: handleHoverStart,
    handleHoverEnd: handleHoverEnd,
    handleMultipleChoiceAnswer: handleMultipleChoiceAnswer
  }) : /*#__PURE__*/React.createElement("div", {
    className: "w-card"
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      textAlign: 'center',
      padding: 'var(--spacing-large)'
    }
  }, /*#__PURE__*/React.createElement("div", null, "Loading word..."))), !showNoGroupsMessage && quizMode !== 'conjugations' && quizMode !== 'declensions' && quizMode !== 'journey' && /*#__PURE__*/React.createElement("div", {
    className: "w-nav-controls"
  }, /*#__PURE__*/React.createElement("button", {
    className: "w-button",
    onClick: prevCard
  }, "\u2190 Previous"), /*#__PURE__*/React.createElement("div", {
    className: "w-nav-center"
  }), /*#__PURE__*/React.createElement("button", {
    className: "w-button",
    onClick: nextCard
  }, "Next \u2192")), !showNoGroupsMessage && quizMode !== 'conjugations' && quizMode !== 'declensions' && quizMode !== 'journey' && /*#__PURE__*/React.createElement(StatsDisplay, {
    stats: wordListState.stats,
    onReset: resetCards
  }), /*#__PURE__*/React.createElement(SettingsModal, null), /*#__PURE__*/React.createElement(StudyMaterialsModal, {
    isOpen: showStudyMaterialsModal,
    onClose: function onClose() {
      return setShowStudyMaterialsModal(false);
    },
    totalSelectedWords: totalSelectedWords,
    availableCorpora: availableCorpora,
    corporaData: corporaData,
    selectedGroups: selectedGroups,
    setSelectedGroups: setSelectedGroups,
    resetAllSettings: resetAllSettings,
    safeStorage: safeStorage
  }));
};
window.FlashCardApp = FlashCardApp;
window.Trakaido = FlashCardApp;
;




// Initialize the React app with React 17/18 compatibility
document.addEventListener('DOMContentLoaded', function() {
    const container = document.getElementById('react-root');
    
    // Check if we have React 18 createRoot or fall back to React 17 render
    if (ReactDOM.createRoot) {
        // React 18
        const root = ReactDOM.createRoot(container);
        root.render(React.createElement(window.FlashCardApp || window.Trakaido));
    } else {
        // React 17 fallback
        ReactDOM.render(React.createElement(window.FlashCardApp || window.Trakaido), container);
    }
});

    </script>
</body>
</html>
